<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scraping Logs - OVH Tracker</title>
    <link rel="stylesheet" href="/css/shared-theme.css">
    <link rel="stylesheet" href="/dashboard/css/navigation.css">
    <style>
        /* Initialize theme immediately to prevent flash */
        html {
            color-scheme: light;
        }
        html.dark-mode {
            color-scheme: dark;
        }
        :root {
            /* Light Mode (default - matching other pages) */
            --bg-primary: #ffffff;
            --bg-secondary: #f5f7fa;
            --bg-card: #ffffff;
            --bg-card-hover: #f0f4f8;
            --text-primary: #1a1a1a;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            --border-color: #e2e8f0;
            --shadow: rgba(0, 0, 0, 0.08);
            --accent-primary: #0099ff;
            --accent-secondary: #00d4ff;
            --accent-ovh: #123f6d;
            --success: #34d399;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: #3b82f6;
            --input-bg: #ffffff;
            --modal-bg: rgba(255, 255, 255, 0.98);
        }

        body.dark-mode {
            /* Dark Mode (matching other pages) */
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --bg-card-hover: #1a4d7a;
            --text-primary: #ffffff;
            --text-secondary: #aaa;
            --text-muted: #666;
            --border-color: #333;
            --shadow: rgba(0, 0, 0, 0.3);
            --accent-primary: #00d4ff;
            --accent-secondary: #0099ff;
            --accent-ovh: #4a9eff;
            --success: #34d399;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: #3b82f6;
            --input-bg: #0f3460;
            --modal-bg: rgba(15, 52, 96, 0.98);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0;
            margin: 0;
            padding-top: 60px; /* Space for fixed navigation menu */
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        /* Navigation menu spacing */
        .nav-menu {
            margin-bottom: 0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header style is now in shared-theme.css as .page-header */
        header {
            margin-bottom: 20px;
        }
        
        header h1 {
            margin-bottom: 8px;
        }

        /* Navigation menu styles */
        .nav-menu-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .theme-toggle {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .version-badge {
            background: rgba(0, 212, 255, 0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .filters {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #0099ff;
            color: white;
        }

        .btn-primary:hover {
            background: #0088ee;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .logs-container {
            background: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .logs-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logs-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: 120px 100px 150px 1fr auto;
            gap: 15px;
            align-items: center;
            transition: background 0.2s;
        }

        .log-entry:hover {
            background: var(--bg-secondary);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .log-level {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .log-level.info {
            background: #dbeafe;
            color: #1e40af;
        }

        .log-level.success {
            background: #d1fae5;
            color: #065f46;
        }

        .log-level.warning {
            background: #fef3c7;
            color: #92400e;
        }

        .log-level.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .log-source {
            font-weight: 500;
            color: var(--text-primary);
        }

        .log-message {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .log-details {
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .log-details:hover {
            color: var(--text-primary);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .empty {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auto-refresh input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        @media (max-width: 768px) {
            .log-entry {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <nav class="nav-menu">
        <div class="nav-menu-left">
            <a href="/" class="nav-logo">
                <svg width="40" height="40" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" fill="#123f6d"/>
                    <text x="50" y="65" font-size="40" fill="#00d4ff" text-anchor="middle" font-weight="bold">O</text>
                </svg>
                <span>Customer Feedbacks Tracker</span>
            </a>
            <div class="nav-tabs">
                <a href="/dashboard" class="nav-tab">
                    <span class="nav-tab-icon">üìä</span>
                    <span>Dashboard Analytics</span>
                </a>
                <a href="/improvements" class="nav-tab">
                    <span class="nav-tab-icon">üí°</span>
                    <span>Improvements Opportunities</span>
                </a>
                <a href="/scraping" class="nav-tab">
                    <span class="nav-tab-icon">üì•</span>
                    <span>Feedbacks Collection</span>
                </a>
                <a href="/logs" class="nav-tab active">
                    <span class="nav-tab-icon">üìã</span>
                    <span>Scraping Logs</span>
                </a>
                <a href="/settings" class="nav-tab">
                    <span class="nav-tab-icon">‚öôÔ∏è</span>
                    <span>Settings</span>
                </a>
                <a href="#" class="nav-tab" onclick="event.preventDefault(); window.toggleHelpMenu(); return false;">
                    <span class="nav-tab-icon">‚ùì</span>
                    <span>Help</span>
                </a>
            </div>
        </div>
        <div class="nav-menu-right">
            <button class="btn-scrape-compact" id="scrapeAllBtn" title="Scrape new data from all sources">
                üÜï Scrape
            </button>
            <button class="btn-cancel-scraping-compact" id="cancelScrapingBtn" style="display: none; padding: 4px 12px; font-size: 0.85em; background: #ef4444; color: white; border: 1px solid #dc2626; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;" onclick="cancelScrape()" title="Cancel current scraping job">
                ‚ùå Cancel
            </button>
            <a href="docs/SLIDE_PITCH_PROJET.html" target="_blank" class="beta-badge" title="Voir le pitch du projet" style="text-decoration: none; display: inline-block;">BETA</a>
            <span class="version-badge" id="versionBadge">v1.0.1</span>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Mode">üåì</button>
        </div>
    </nav>

    <div class="container">
        <header class="page-header">
            <h1>üìã Scraping Logs</h1>
            <p>Real-time monitoring of scraping operations</p>
        </header>

        <div class="stats">
            <div class="stat-card">
                <h3>Total Logs</h3>
                <div class="value" id="statTotal">0</div>
            </div>
            <div class="stat-card">
                <h3>Errors</h3>
                <div class="value" id="statErrors" style="color: var(--error)">0</div>
            </div>
            <div class="stat-card">
                <h3>Success</h3>
                <div class="value" id="statSuccess" style="color: var(--success)">0</div>
            </div>
            <div class="stat-card">
                <h3>Active Sources</h3>
                <div class="value" id="statSources">0</div>
            </div>
        </div>

        <!-- Scraping Progress Bar -->
        <div id="scrapingProgressContainer" style="display: none; margin-bottom: 24px; padding: 20px; background: var(--bg-card); border-radius: 8px; box-shadow: 0 2px 8px var(--shadow); border: 1px solid var(--border-color);" data-status="running" data-percentage="0%">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                <span id="scrapingProgressText" style="display: block; text-align: left; color: var(--text-secondary); font-size: 0.9em; flex: 1;">Initializing scraping job...</span>
                <button id="cancelProgressBtn" onclick="cancelScrape()" style="display: none; padding: 6px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 0.85em; transition: all 0.2s ease; white-space: nowrap;" title="Cancel current scraping job">
                    ‚ùå Cancel
                </button>
            </div>
            <div style="width: 100%; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                <div id="scrapingProgressBar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="height: 100%; background: linear-gradient(90deg, #00d4ff, #0099ff); width: 0%; transition: width 0.3s ease;"></div>
            </div>
        </div>

        <!-- Filters (moved below progress bar) -->
        <div class="filters" style="margin-bottom: 20px;">
            <div class="filter-group">
                <label>Source</label>
                <select id="filterSource">
                    <option value="">All sources</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Level</label>
                <select id="filterLevel">
                    <option value="">All levels</option>
                    <option value="info">Info</option>
                    <option value="success">Success</option>
                    <option value="warning">Warning</option>
                    <option value="error">Error</option>
                    <option value="debug">Debug</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Limit</label>
                <input type="number" id="filterLimit" value="100" min="10" max="1000" step="10">
            </div>
        </div>

        <div class="actions">
            <button id="refreshBtn" class="btn-primary" onclick="loadLogs()">üîÑ Refresh</button>
            <button class="btn-danger" onclick="clearLogs()">üóëÔ∏è Clear</button>
            <button class="btn-primary" onclick="testProgressBar()" style="background: #10b981; margin-left: 10px;" title="Test progress bar display">üß™ Test Progress Bar</button>
            <div class="auto-refresh">
                <input type="checkbox" id="autoRefresh" onchange="toggleAutoRefresh()" checked>
                <label for="autoRefresh">Auto refresh (2s)</label>
            </div>
        </div>

        <div class="logs-container">
            <div class="logs-header">
                <h2>Recent Logs</h2>
                <span id="lastUpdate"></span>
            </div>
            <div class="logs-list" id="logsList">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        let autoRefreshInterval = null;
        let sources = new Set();
        let currentJobId = null;
        let jobStatusInterval = null;
        
        // Load/save job ID from localStorage
        function loadLastJob() {
            const jobId = localStorage.getItem('ovh_last_job');
            const sourceName = localStorage.getItem('ovh_last_job_source') || '';
            
            // Auto-cleanup problematic job ID
            if (jobId && jobId.includes('84d4fd06-ae2e-43a1-9387-e037a668f75a')) {
                console.warn('üßπ Auto-cleaning stale job ID from localStorage');
                localStorage.removeItem('ovh_last_job');
                localStorage.removeItem('ovh_last_job_source');
                return { jobId: null, sourceName: '' };
            }
            
            return { jobId: jobId, sourceName: sourceName };
        }
        
        function persistLastJob(jobId, sourceName = '') {
            if (jobId) {
                localStorage.setItem('ovh_last_job', jobId);
                if (sourceName) {
                    localStorage.setItem('ovh_last_job_source', sourceName);
                }
            } else {
                localStorage.removeItem('ovh_last_job');
                localStorage.removeItem('ovh_last_job_source');
            }
        }
        
        function showCancelBtn(show) {
            const cancelBtn = document.getElementById('cancelProgressBtn');
            const cancelScrapingBtn = document.getElementById('cancelScrapingBtn');
            if (cancelBtn) {
                cancelBtn.style.display = show ? 'inline-block' : 'none';
            }
            if (cancelScrapingBtn) {
                cancelScrapingBtn.style.display = show ? 'inline-block' : 'none';
            }
        }
        
        async function cancelScrape() {
            console.log('Cancel button clicked, currentJobId:', currentJobId);
            
            if (currentJobId) {
                try {
                    console.log(`Attempting to cancel job: ${currentJobId}`);
                    const response = await fetch(`${API_BASE}/scrape/jobs/${currentJobId}/cancel`, {
                        method: 'POST'
                    });
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Cancel response:', result);
                        showToast('Job cancellation requested', 'info');
                        
                        const progressText = document.getElementById('scrapingProgressText');
                        if (progressText) {
                            progressText.textContent = 'Cancelling job...';
                        }
                    } else {
                        const errorText = await response.text();
                        console.error(`Cancel failed: ${response.status} - ${errorText}`);
                        showToast('Cancel failed', 'error');
                    }
                } catch (e) {
                    console.error(`Error cancelling job: ${e.message}`, e);
                    showToast(`Error: ${e.message}`, 'error');
                }
                
                // Stop polling immediately
                if (jobStatusInterval) {
                    clearInterval(jobStatusInterval);
                    jobStatusInterval = null;
                    console.log('Polling stopped');
                }
                
                // Clear job ID and localStorage
                persistLastJob(null);
                currentJobId = null;
                showCancelBtn(false);
                
                // Hide progress bar after a short delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('scrapingProgressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } else {
                console.warn('No currentJobId to cancel');
            }
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#34d399' : '#0099ff'};
                color: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                font-weight: 500;
                animation: slideIn 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        async function pollJobStatus(jobId, sourceName = '') {
            if (jobStatusInterval) {
                clearInterval(jobStatusInterval);
            }
            
            const progressBar = document.getElementById('scrapingProgressBar');
            const progressText = document.getElementById('scrapingProgressText');
            const progressContainer = document.getElementById('scrapingProgressContainer');
            
            // Show progress bar
            if (progressContainer) {
                progressContainer.style.display = 'block';
                progressContainer.setAttribute('data-status', 'running');
                progressContainer.setAttribute('data-percentage', '0%');
            }
            showCancelBtn(true);
            
            // Poll immediately first time
            (async () => {
                try {
                    console.log(`Polling job status for ${jobId.substring(0, 8)}...`);
                    const response = await fetch(`${API_BASE}/scrape/jobs/${jobId}`);
                    if (response.ok) {
                        const job = await response.json();
                        const status = job.status || 'unknown';
                        const progress = job.progress || { total: 0, completed: 0 };
                        const completed = progress.completed || 0;
                        const total = progress.total || 0;
                        
                        if (total > 0 && progressBar) {
                            const percentage = Math.round((completed / total) * 100);
                            progressBar.style.width = `${percentage}%`;
                            progressBar.setAttribute('aria-valuenow', percentage);
                            if (progressContainer) {
                                progressContainer.setAttribute('data-percentage', `${percentage}%`);
                                progressContainer.setAttribute('data-status', status === 'running' ? 'running' : status);
                            }
                        }
                        
                        if (progressText) {
                            progressText.textContent = `scraping in progress: ${completed}/${total} tasks completed (${total > 0 ? Math.round((completed / total) * 100) : 0}%)`;
                        }
                        
                        // Check if job is finished
                        if (status === 'completed' || status === 'failed' || status === 'cancelled') {
                            if (jobStatusInterval) {
                                clearInterval(jobStatusInterval);
                                jobStatusInterval = null;
                            }
                            currentJobId = null;
                            persistLastJob(null);
                            showCancelBtn(false);
                            if (progressText) {
                                progressText.textContent = `Job ${status}: ${completed}/${total} tasks completed`;
                            }
                            setTimeout(() => {
                                if (progressContainer) {
                                    progressContainer.style.display = 'none';
                                }
                            }, 5000);
                        }
                    } else if (response.status === 404) {
                        console.warn(`Job ${jobId.substring(0, 8)}... not found (404), stopping polling`);
                        if (jobStatusInterval) {
                            clearInterval(jobStatusInterval);
                            jobStatusInterval = null;
                        }
                        currentJobId = null;
                        persistLastJob(null);
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                        showCancelBtn(false);
                        return;
                    }
                } catch (e) {
                    console.error('Error in immediate poll:', e);
                }
            })();
            
            // Poll every 2 seconds
            jobStatusInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/scrape/jobs/${jobId}`);
                    if (!response.ok) {
                        if (response.status === 404) {
                            console.warn(`Job ${jobId.substring(0, 8)}... not found (404), stopping polling`);
                            clearInterval(jobStatusInterval);
                            jobStatusInterval = null;
                            currentJobId = null;
                            persistLastJob(null);
                            const progressContainer = document.getElementById('scrapingProgressContainer');
                            if (progressContainer) {
                                progressContainer.style.display = 'none';
                            }
                            showCancelBtn(false);
                            return;
                        }
                        console.error(`Failed to fetch job status: ${response.status}`);
                        return;
                    }
                    
                    const job = await response.json();
                    const status = job.status || 'unknown';
                    const progress = job.progress || { total: 0, completed: 0 };
                    const completed = progress.completed || 0;
                    const total = progress.total || 0;
                    
                    const currentProgressBar = document.getElementById('scrapingProgressBar');
                    const currentProgressText = document.getElementById('scrapingProgressText');
                    const currentProgressContainer = document.getElementById('scrapingProgressContainer');
                    
                    if (currentProgressBar) {
                        if (total > 0) {
                            const percentage = Math.round((completed / total) * 100);
                            currentProgressBar.style.width = `${percentage}%`;
                            currentProgressBar.setAttribute('aria-valuenow', percentage);
                            
                            if (currentProgressContainer) {
                                currentProgressContainer.setAttribute('data-percentage', `${percentage}%`);
                                currentProgressContainer.setAttribute('data-status', status === 'running' ? 'running' : status);
                            }
                        }
                    }
                    
                    if (currentProgressText) {
                        currentProgressText.textContent = `scraping in progress: ${completed}/${total} tasks completed (${total > 0 ? Math.round((completed / total) * 100) : 0}%)`;
                    }
                    
                    // Check if job is finished
                    if (status === 'completed' || status === 'failed' || status === 'cancelled') {
                        clearInterval(jobStatusInterval);
                        jobStatusInterval = null;
                        currentJobId = null;
                        persistLastJob(null);
                        showCancelBtn(false);
                        if (currentProgressText) {
                            currentProgressText.textContent = `Job ${status}: ${completed}/${total} tasks completed`;
                        }
                        setTimeout(() => {
                            if (currentProgressContainer) {
                                currentProgressContainer.style.display = 'none';
                            }
                        }, 5000);
                    }
                } catch (e) {
                    console.error('Error polling job status:', e);
                }
            }, 2000);
        }
        
        // Resume last job on page load
        (function resumeLastJob() {
            try {
                // Auto-cleanup problematic job ID before loading
                const storedJobId = localStorage.getItem('ovh_last_job');
                if (storedJobId && storedJobId.includes('84d4fd06-ae2e-43a1-9387-e037a668f75a')) {
                    console.warn('üßπ Auto-cleaning problematic job ID on page load');
                    localStorage.removeItem('ovh_last_job');
                    localStorage.removeItem('ovh_last_job_source');
                    if (jobStatusInterval) {
                        clearInterval(jobStatusInterval);
                        jobStatusInterval = null;
                    }
                    return;
                }
                
                const lastJob = loadLastJob();
                const lastJobId = lastJob?.jobId;
                
                // First, check if there's a job in localStorage
                if (lastJobId && typeof lastJobId === 'string' && lastJobId.trim() !== '') {
                    console.log('ResumeLastJob: Found valid job ID in localStorage:', lastJobId.substring(0, 8) + '...');
                    
                    // Try to fetch job status first
                    fetch(`${API_BASE}/scrape/jobs/${encodeURIComponent(lastJobId)}`)
                        .then(resp => {
                            if (resp.status === 404) {
                                console.warn(`Job ${lastJobId.substring(0, 8)}... not found (404), clearing persisted job`);
                                persistLastJob(null);
                                // Continue to check for running jobs from API
                                checkRunningJobsFromAPI();
                                return;
                            }
                            if (resp.ok) {
                                return resp.json().then(job => {
                                    if (job.status === 'running' || job.status === 'pending') {
                                        console.log(`Resuming job ${lastJobId.substring(0, 8)}... on logs page`);
                                        currentJobId = lastJobId;
                                        pollJobStatus(lastJobId, lastJob.sourceName);
                                    } else {
                                        // Job finished, clean up
                                        console.log(`Job ${lastJobId.substring(0, 8)}... is ${job.status}, cleaning up`);
                                        persistLastJob(null);
                                        const progressContainer = document.getElementById('scrapingProgressContainer');
                                        if (progressContainer) {
                                            progressContainer.style.display = 'none';
                                        }
                                        showCancelBtn(false);
                                        // Check for other running jobs
                                        checkRunningJobsFromAPI();
                                    }
                                });
                            }
                        })
                        .catch(error => {
                            console.warn('Could not check job status on page load:', error);
                            persistLastJob(null);
                            // Check for running jobs from API as fallback
                            checkRunningJobsFromAPI();
                        });
                } else {
                    // No job in localStorage, check API for running jobs
                    checkRunningJobsFromAPI();
                }
            } catch (error) {
                console.error('Error in resume job function:', error);
                localStorage.removeItem('ovh_last_job');
                localStorage.removeItem('ovh_last_job_source');
                // Try to check API as fallback
                checkRunningJobsFromAPI();
            }
        })();
        
        // Check for running jobs from API (useful after server restart)
        async function checkRunningJobsFromAPI() {
            try {
                // Don't check if we already have a job being tracked and polling is active
                if (currentJobId && jobStatusInterval) {
                    console.log(`Skipping job check - already tracking job ${currentJobId.substring(0, 8)}...`);
                    return true;
                }
                
                console.log('Checking for running jobs from API...');
                
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                const response = await fetch(`${API_BASE}/scrape/jobs?status=running&limit=5`, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('API response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('API response data:', data);
                    const jobs = data.jobs || [];
                    
                    if (jobs.length > 0) {
                        const runningJob = jobs[0];
                        const jobId = runningJob.id;
                        console.log(`‚úÖ Found running job from API: ${jobId.substring(0, 8)}...`);
                        
                        // Update localStorage
                        persistLastJob(jobId);
                        currentJobId = jobId;
                        
                        // Show progress bar immediately
                        const progressContainer = document.getElementById('scrapingProgressContainer');
                        if (progressContainer) {
                            progressContainer.style.display = 'block';
                            console.log('Progress bar displayed');
                        }
                        
                        // Show cancel button
                        showCancelBtn(true);
                        
                        // Start polling
                        pollJobStatus(jobId, '');
                        return true; // Job found
                    } else {
                        console.log('No running jobs found');
                        // Only hide progress bar if we don't already have a job being tracked
                        // AND if there's no active polling interval
                        if (!currentJobId && !jobStatusInterval) {
                            const progressContainer = document.getElementById('scrapingProgressContainer');
                            if (progressContainer) {
                                progressContainer.style.display = 'none';
                            }
                            showCancelBtn(false);
                        } else if (currentJobId) {
                            console.log(`Keeping progress bar visible - job ${currentJobId.substring(0, 8)}... is being tracked`);
                        }
                        return false; // No job found
                    }
                } else {
                    const errorText = await response.text();
                    console.warn('API returned error:', response.status, errorText);
                    // Don't hide bar on API error if we have a job being tracked
                    if (!currentJobId && !jobStatusInterval) {
                        const progressContainer = document.getElementById('scrapingProgressContainer');
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                    }
                    return false;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.warn('Job check timed out');
                } else {
                    console.error('Could not check running jobs from API:', error);
                }
                // Don't hide bar on error if we have a job being tracked
                if (!currentJobId && !jobStatusInterval) {
                    const progressContainer = document.getElementById('scrapingProgressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }
                return false;
            }
        }

        let isLoadingLogs = false; // Prevent concurrent requests
        let consecutiveErrors = 0; // Track consecutive errors
        const MAX_CONSECUTIVE_ERRORS = 3; // Stop auto-refresh after 3 consecutive errors
        
        async function loadLogs() {
            // Prevent concurrent requests
            if (isLoadingLogs) {
                console.log('Logs already loading, skipping...');
                return;
            }
            
            const refreshBtn = document.getElementById('refreshBtn');
            
            // Disable button and show loading state
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.textContent = '‚è≥ Loading...';
            }
            
            isLoadingLogs = true;
            
            const source = document.getElementById('filterSource').value;
            const level = document.getElementById('filterLevel').value;
            const limit = parseInt(document.getElementById('filterLimit').value) || 100;

            try {
                const params = new URLSearchParams();
                if (source) params.append('source', source);
                if (level) params.append('level', level);
                params.append('limit', limit);

                console.log(`Loading logs from ${API_BASE}/api/logs?${params}`);
                
                // Add timeout to prevent hanging requests
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(`${API_BASE}/api/logs?${params}`, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }
                const data = await response.json();
                
                console.log('API response:', data);
                
                // Handle both {logs: [...]} and [...] formats
                let logs = Array.isArray(data) ? data : (data.logs || []);
                
                console.log(`Loaded ${logs.length} logs from API (filtered by level: ${level || 'none'})`);
                
                console.log(`Displaying ${logs.length} logs`);
                
                displayLogs(logs);
                updateStats(logs);
                document.getElementById('lastUpdate').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
                
                // Reset error counter on success
                consecutiveErrors = 0;
                
                // Show success feedback
                if (refreshBtn) {
                    refreshBtn.textContent = '‚úÖ Refreshed';
                    setTimeout(() => {
                        refreshBtn.textContent = 'üîÑ Refresh';
                        refreshBtn.disabled = false;
                    }, 1000);
                }
            } catch (error) {
                console.error('Error loading logs:', error);
                
                // Don't show error if it's just an abort (timeout or cancelled)
                if (error.name === 'AbortError') {
                    console.log('Request was aborted (timeout or cancelled)');
                    if (refreshBtn) {
                        refreshBtn.textContent = 'üîÑ Refresh';
                        refreshBtn.disabled = false;
                    }
                    isLoadingLogs = false;
                    return;
                }
                
                consecutiveErrors++;
                const errorMsg = error.message || 'Error loading logs';
                const isNetworkError = errorMsg.includes('NetworkError') || errorMsg.includes('Failed to fetch');
                
                // If too many consecutive errors, stop auto-refresh
                if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                    console.warn(`Too many consecutive errors (${consecutiveErrors}), stopping auto-refresh`);
                    const autoRefreshCheckbox = document.getElementById('autoRefresh');
                    if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
                        autoRefreshCheckbox.checked = false;
                        toggleAutoRefresh();
                        showToast('Server unavailable - Auto-refresh disabled', 'error');
                    }
                }
                
                // Only show error message if we don't have any logs displayed
                const logsList = document.getElementById('logsList');
                if (logsList) {
                    if (logsList.children.length === 0) {
                        logsList.innerHTML = `<div class="empty">
                            ‚ùå ${isNetworkError ? 'Server unavailable' : errorMsg}
                            <br><small>Please check if the server is running on port 8000</small>
                        </div>`;
                    } else if (isNetworkError && consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                        // Show warning banner at top of logs
                        const warningBanner = document.createElement('div');
                        warningBanner.id = 'serverWarningBanner';
                        warningBanner.style.cssText = 'background: #fee; border: 1px solid #fcc; padding: 10px; margin-bottom: 10px; border-radius: 4px; color: #c33;';
                        warningBanner.innerHTML = '‚ö†Ô∏è Server unavailable - Auto-refresh disabled. Please restart the server.';
                        const firstLog = logsList.firstElementChild;
                        if (firstLog && !document.getElementById('serverWarningBanner')) {
                            logsList.insertBefore(warningBanner, firstLog);
                        }
                    }
                }
                
                // Show toast only for network errors (but not too frequently)
                if (isNetworkError && consecutiveErrors <= MAX_CONSECUTIVE_ERRORS) {
                    showToast(`Connection error (${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS})`, 'warning');
                } else if (!isNetworkError) {
                    showToast(`Error: ${errorMsg}`, 'error');
                }
                
                // Restore button state on error
                if (refreshBtn) {
                    refreshBtn.textContent = 'üîÑ Refresh';
                    refreshBtn.disabled = false;
                }
            } finally {
                isLoadingLogs = false;
            }
        }

        function displayLogs(logs) {
            const container = document.getElementById('logsList');
            
            console.log(`displayLogs called with ${logs ? logs.length : 0} logs`);
            
            if (!logs || logs.length === 0) {
                container.innerHTML = '<div class="empty">No logs available</div>';
                return;
            }

            // Prepare details cache for event listeners
            const detailsCache = logs.map(log => {
                if (!log.details) return null;
                if (typeof log.details === 'string') {
                    try {
                        const parsed = JSON.parse(log.details);
                        return JSON.stringify(parsed, null, 2);
                    } catch {
                        return log.details;
                    }
                } else {
                    return JSON.stringify(log.details, null, 2);
                }
            });

            container.innerHTML = logs.map((log, index) => {
                try {
                    const timestamp = new Date(log.timestamp).toLocaleString('en-US');
                    
                    return `
                        <div class="log-entry">
                            <div class="log-timestamp">${timestamp}</div>
                            <div class="log-level ${log.level || 'info'}">${log.level || 'info'}</div>
                            <div class="log-source">${log.source || 'N/A'}</div>
                            <div class="log-message">${escapeHtml(log.message || '')}</div>
                            ${detailsCache[index] ? `<div class="log-details" data-details-index="${index}">üìÑ</div>` : '<div></div>'}
                        </div>
                    `;
                } catch (e) {
                    console.error('Error rendering log entry:', e, log);
                    return `<div class="log-entry"><div class="log-message">Error rendering log: ${escapeHtml(String(e))}</div></div>`;
                }
            }).join('');

            // Attach event listeners to detail buttons
            container.querySelectorAll('.log-details[data-details-index]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-details-index'));
                    const details = detailsCache[index];
                    if (details) {
                        showDetails(details);
                    }
                });
            });

            // Update sources dropdown
            logs.forEach(log => {
                if (log.source && !sources.has(log.source)) {
                    sources.add(log.source);
                    const option = document.createElement('option');
                    option.value = log.source;
                    option.textContent = log.source;
                    document.getElementById('filterSource').appendChild(option);
                }
            });
        }

        function updateStats(logs) {
            document.getElementById('statTotal').textContent = logs.length;
            document.getElementById('statErrors').textContent = logs.filter(l => l.level === 'error').length;
            document.getElementById('statSuccess').textContent = logs.filter(l => l.level === 'success').length;
            
            const uniqueSources = new Set(logs.map(l => l.source).filter(Boolean));
            document.getElementById('statSources').textContent = uniqueSources.size;
        }

        function showDetails(details) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            // Create modal content
            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--bg-card);
                border-radius: 12px;
                padding: 24px;
                max-width: 80%;
                max-height: 80vh;
                overflow: auto;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                border: 1px solid var(--border-color);
            `;
            
            // Create header
            const header = document.createElement('div');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 16px;
                padding-bottom: 12px;
                border-bottom: 1px solid var(--border-color);
            `;
            
            const title = document.createElement('h3');
            title.textContent = 'üìÑ Log Details';
            title.style.cssText = 'margin: 0; color: var(--text-primary);';
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = `
                background: transparent;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: var(--text-secondary);
                padding: 0;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                transition: all 0.2s ease;
            `;
            closeBtn.onmouseover = () => {
                closeBtn.style.background = 'var(--bg-secondary)';
                closeBtn.style.color = 'var(--text-primary)';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = 'transparent';
                closeBtn.style.color = 'var(--text-secondary)';
            };
            closeBtn.onclick = () => modal.remove();
            
            // Create content area
            const pre = document.createElement('pre');
            pre.textContent = details;
            pre.style.cssText = `
                background: var(--bg-secondary);
                padding: 16px;
                border-radius: 8px;
                overflow-x: auto;
                font-family: 'Courier New', monospace;
                font-size: 0.9em;
                margin: 0;
                color: var(--text-primary);
                white-space: pre-wrap;
                word-wrap: break-word;
            `;
            
            // Assemble modal
            header.appendChild(title);
            header.appendChild(closeBtn);
            content.appendChild(header);
            content.appendChild(pre);
            modal.appendChild(content);
            
            // Close on overlay click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            // Close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Add to DOM
            document.body.appendChild(modal);
            
            // Focus close button for accessibility
            closeBtn.focus();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function clearLogs() {
            if (!confirm('Are you sure you want to clear all logs?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/logs`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    loadLogs();
                    showToast('Logs cleared successfully', 'success');
                } else {
                    const errorText = await response.text();
                    showToast(`Error clearing logs: ${errorText}`, 'error');
                }
            } catch (error) {
                console.error('Error clearing logs:', error);
                showToast(`Error clearing logs: ${error.message}`, 'error');
            }
        }

        function toggleAutoRefresh() {
            const enabled = document.getElementById('autoRefresh').checked;
            
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            
            // Remove warning banner when re-enabling auto-refresh
            if (enabled) {
                const warningBanner = document.getElementById('serverWarningBanner');
                if (warningBanner) {
                    warningBanner.remove();
                }
                // Reset error counter when manually re-enabling
                consecutiveErrors = 0;
            }
            
            if (enabled) {
                // Increased interval to 3 seconds to avoid too many concurrent requests
                autoRefreshInterval = setInterval(() => {
                    // Only load if not already loading
                    if (!isLoadingLogs) {
                        loadLogs();
                    }
                }, 3000);
            }
        }
        
        // Start auto-refresh by default
        function startAutoRefresh() {
            const checkbox = document.getElementById('autoRefresh');
            if (!checkbox.checked) {
                checkbox.checked = true;
            }
            toggleAutoRefresh();
        }

        function toggleTheme() {
            const body = document.body;
            const html = document.documentElement;
            const isDark = body.classList.contains('dark-mode');
            
            if (isDark) {
                body.classList.remove('dark-mode');
                html.classList.remove('dark-mode');
                html.classList.add('light-mode');
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-mode');
                html.classList.add('dark-mode');
                html.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark');
            }
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const html = document.documentElement;
            
            // Light mode par d√©faut (comme le reste de l'application)
            if (savedTheme === 'dark') {
                body.classList.add('dark-mode');
                html.classList.add('dark-mode');
                html.classList.remove('light-mode');
            } else {
                // Light mode par d√©faut
                body.classList.remove('dark-mode');
                html.classList.remove('dark-mode');
                html.classList.add('light-mode');
            }
        }

        async function loadVersion() {
            try {
                const response = await fetch(`${API_BASE}/api/version`);
                if (response.ok) {
                    const data = await response.json();
                    const versionBadge = document.getElementById('versionBadge');
                    if (versionBadge) {
                        versionBadge.textContent = `v${data.version}`;
                        if (data.build_date) {
                            versionBadge.title = `Version ${data.version} - Build: ${new Date(data.build_date).toLocaleDateString()}`;
                        } else {
                            versionBadge.title = `Version ${data.version}`;
                        }
                    }
                }
            } catch (error) {
                console.warn('Failed to load version:', error);
            }
        }

        // Initialize theme IMMEDIATELY to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const html = document.documentElement;
            // Light mode par d√©faut (comme le reste de l'application)
            if (savedTheme === 'dark') {
                html.classList.add('dark-mode');
            } else {
                html.classList.add('light-mode');
            }
        })();

        // Make loadLogs available globally
        window.loadLogs = loadLogs;
        window.clearLogs = clearLogs;
        window.toggleAutoRefresh = toggleAutoRefresh;
        
        // Debug function to test progress bar display
        window.testProgressBar = function() {
            const progressContainer = document.getElementById('scrapingProgressContainer');
            const progressBar = document.getElementById('scrapingProgressBar');
            const progressText = document.getElementById('scrapingProgressText');
            const cancelBtn = document.getElementById('cancelProgressBtn');
            
            console.log('üß™ Testing progress bar display...');
            console.log('Container found:', !!progressContainer);
            console.log('Bar found:', !!progressBar);
            console.log('Text found:', !!progressText);
            
            if (!progressContainer) {
                console.error('‚ùå Progress container not found!');
                alert('Progress container not found! Check console for details.');
                return;
            }
            
            // Show progress bar
            progressContainer.style.display = 'block';
            progressContainer.setAttribute('data-status', 'running');
            progressContainer.setAttribute('data-percentage', '50%');
            console.log('‚úÖ Progress bar displayed');
            
            // Update progress bar
            if (progressBar) {
                progressBar.style.width = '50%';
                progressBar.setAttribute('aria-valuenow', 50);
                console.log('‚úÖ Progress bar set to 50%');
            }
            
            // Update text
            if (progressText) {
                progressText.textContent = 'üß™ Test: 5/10 tasks completed (50%)';
                console.log('‚úÖ Progress text updated');
            }
            
            // Show cancel button
            if (cancelBtn) {
                cancelBtn.style.display = 'inline-block';
                console.log('‚úÖ Cancel button shown');
            }
            
            showToast('Progress bar test - should be visible now!', 'info');
            
            // Also check for running jobs
            console.log('Checking for real running jobs...');
            checkRunningJobsFromAPI().then(hasJob => {
                if (hasJob) {
                    console.log('‚úÖ Real job found, will update progress bar');
                } else {
                    console.log('‚ÑπÔ∏è No real job found, keeping test display');
                }
            });
        };

        // Periodic check for running jobs (every 5 seconds)
        let jobCheckInterval = null;
        function startJobCheckInterval() {
            if (jobCheckInterval) {
                clearInterval(jobCheckInterval);
            }
            // Check every 5 seconds for running jobs
            jobCheckInterval = setInterval(() => {
                // Only check if we don't already have a job being tracked
                // AND if the progress bar is not visible (to avoid hiding it if it's already showing)
                if (!currentJobId) {
                    const progressContainer = document.getElementById('scrapingProgressContainer');
                    const isVisible = progressContainer && progressContainer.style.display !== 'none';
                    // Only check if bar is not visible to avoid hiding it unnecessarily
                    if (!isVisible) {
                        checkRunningJobsFromAPI();
                    }
                } else {
                    // If we have a currentJobId, verify it's still valid
                    // But don't hide the bar if polling is active
                    const progressContainer = document.getElementById('scrapingProgressContainer');
                    if (progressContainer && progressContainer.style.display === 'none') {
                        // Bar was hidden but we have a job ID - restore it
                        progressContainer.style.display = 'block';
                        pollJobStatus(currentJobId, '');
                    }
                }
            }, 5000);
        }
        
        // Load logs on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeTheme();
                loadLogs();
                // D√©marrer l'actualisation automatique par d√©faut
                startAutoRefresh();
                // Check for running jobs after a short delay to ensure API is ready
                setTimeout(checkRunningJobsFromAPI, 500);
                // Start periodic check for running jobs
                startJobCheckInterval();
            });
        } else {
            initializeTheme();
            loadLogs();
            // D√©marrer l'actualisation automatique par d√©faut
            startAutoRefresh();
            // Check for running jobs after a short delay to ensure API is ready
            setTimeout(checkRunningJobsFromAPI, 500);
            // Start periodic check for running jobs
            startJobCheckInterval();
        }

        // Update filters trigger reload
        document.getElementById('filterSource').addEventListener('change', loadLogs);
        document.getElementById('filterLevel').addEventListener('change', loadLogs);
        document.getElementById('filterLimit').addEventListener('change', loadLogs);

        // Help menu function
        window.toggleHelpMenu = function() {
            const menu = document.getElementById('helpMenu');
            if (menu) {
                menu.classList.toggle('active');
            }
        };
    </script>
    
    <!-- Help Menu -->
    <div class="help-menu" id="helpMenu">
        <div class="help-menu-header">
            <h2>üìñ Help & Information</h2>
            <button class="help-menu-close" onclick="window.toggleHelpMenu()">√ó</button>
        </div>
        <div class="help-menu-content">
            <!-- Content loaded dynamically by help-menu-loader.js -->
            <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Loading help content...</p>
        </div>
    </div>

    <script src="/js/help-menu-loader.js"></script>
    <script type="module" src="/dashboard/js/version-loader.js"></script>
    <script type="module">
        import { API } from '/dashboard/js/api.js';
        const api = new API();
        
        // Scrape All button handler
        const scrapeAllBtn = document.getElementById('scrapeAllBtn');
        if (scrapeAllBtn) {
            scrapeAllBtn.addEventListener('click', async () => {
                try {
                    scrapeAllBtn.disabled = true;
                    scrapeAllBtn.innerHTML = '‚è≥ Starting...';
                    
                    // Load keywords from localStorage
                    const saved = localStorage.getItem('ovh_queries');
                    const keywords = saved ? JSON.parse(saved) : [];
                    
                    // Start scraping job
                    const jobData = await api.startScrapingJob(keywords, 50, 2, 0.5);
                    
                    scrapeAllBtn.disabled = false;
                    scrapeAllBtn.innerHTML = 'üÜï Scrape';
                    
                    // Redirect to collection page to see progress
                    window.location.href = '/scraping';
                } catch (error) {
                    console.error('Error starting scraping:', error);
                    scrapeAllBtn.disabled = false;
                    scrapeAllBtn.innerHTML = 'üÜï Scrape';
                    alert(`Error: ${error.message}`);
                }
            });
        }
    </script>
    <script>
        // Close help menu when clicking outside
        document.addEventListener('click', (e) => {
            const helpMenu = document.getElementById('helpMenu');
            if (!helpMenu) return;
            
            const helpTab = document.querySelector('.nav-tab[onclick*="toggleHelpMenu"]');
            const isClickInsideMenu = helpMenu.contains(e.target);
            const isClickOnTab = helpTab && helpTab.contains(e.target);
            
            if (helpMenu.classList.contains('active') && !isClickInsideMenu && !isClickOnTab) {
                helpMenu.classList.remove('active');
            }
        });
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OVH Complaints Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 40px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls button, .controls select, .controls input {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #0f3460;
            color: #fff;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .controls input {
            flex: 1;
            min-width: 200px;
            max-width: 300px;
        }

        .controls button:hover, .controls select:hover {
            background: #00d4ff;
            color: #1a1a2e;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .controls button:focus {
            outline: none;
        }

        .apply-btn {
            background: #00d4ff;
            color: #1a1a2e;
            font-weight: bold;
        }

        .apply-btn:hover {
            background: #0099ff;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stat-card {
            background: rgba(15, 52, 96, 0.6);
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 3px solid #00d4ff;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            background: rgba(15, 52, 96, 0.9);
            border-left-color: #34d399;
            transform: scale(1.05);
        }

        .stat-card strong {
            display: block;
            font-size: 1.8em;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .stat-card small {
            color: #aaa;
            font-size: 0.9em;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .post-card {
            background: rgba(15, 52, 96, 0.5);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .post-card:hover {
            background: rgba(15, 52, 96, 0.8);
            border-color: #00d4ff;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
            transform: translateY(-5px);
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .post-source {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .source-x {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
        }

        .source-reddit {
            background: rgba(255, 69, 0, 0.6);
            color: #fff;
        }

        .source-linkedin {
            background: rgba(0, 119, 181, 0.6);
            color: #fff;
        }

        .source-facebook {
            background: rgba(59, 89, 152, 0.6);
            color: #fff;
        }

        .post-date {
            color: #888;
            font-size: 0.85em;
        }

        .post-author {
            color: #00d4ff;
            font-weight: bold;
            font-size: 0.95em;
        }

        .post-content {
            color: #ccc;
            line-height: 1.6;
            flex-grow: 1;
            max-height: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 212, 255, 0.1);
        }

        .sentiment {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .sentiment-positive {
            background: rgba(52, 211, 153, 0.3);
            color: #34d399;
        }

        .sentiment-negative {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .sentiment-neutral {
            background: rgba(107, 114, 128, 0.3);
            color: #d1d5db;
        }

        .post-url {
            color: #0099ff;
            text-decoration: none;
            font-size: 0.85em;
            word-break: break-all;
        }

        .post-url:hover {
            text-decoration: underline;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-state h2 {
            margin-bottom: 10px;
            color: #aaa;
        }

        .loader {
            text-align: center;
            padding: 40px;
            color: #00d4ff;
        }

        .loader span {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00d4ff;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loader span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loader span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                opacity: 0.3;
                transform: scale(0);
            }
            40% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .logs-container {
            background: rgba(15, 52, 96, 0.8);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 2px solid #00d4ff;
            padding-left: 10px;
        }

        .log-entry.success {
            color: #34d399;
            border-left-color: #34d399;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, #34d399, #10b981);
            color: #fff;
            padding: 18px 28px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(52, 211, 153, 0.4);
            font-size: 0.95em;
            font-weight: 500;
            animation: slideIn 0.5s ease-out;
            z-index: 9999;
            border-left: 4px solid #fff;
            max-width: 400px;
        }

        .toast.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
        }

        .toast.info {
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
        }

        @keyframes slideIn {
            from {
                transform: translateX(500px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(500px);
                opacity: 0;
            }
        }

        .toast.hide {
            animation: slideOut 0.5s ease-out forwards;
        }

        .log-entry.error {
            color: #ef4444;
            border-left-color: #ef4444;
        }

        .log-entry.info {
            color: #00d4ff;
            border-left-color: #00d4ff;
        }

        .log-timestamp {
            color: #888;
            font-size: 0.8em;
            margin-right: 8px;
        }
        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.15);
            border-top-color: #00d4ff;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Job errors modal styles */
        .job-errors-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .job-errors-modal {
            width: 100%;
            max-width: 980px;
            background: linear-gradient(180deg, rgba(22,22,34,0.98), rgba(18,18,28,0.98));
            border-radius: 12px;
            border: 1px solid rgba(239,68,68,0.12);
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            color: #fff;
            padding: 18px;
        }

        .job-errors-header { display:flex; align-items:center; justify-content:space-between; gap:12px }
        .job-errors-title { color:#ffb3b3; margin:0; font-size:1.1em }
        .job-errors-actions button { margin-left:8px; }

        .btn { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:600 }
        .btn-ghost { background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.06) }
        .btn-primary { background:#7c3aed; color:#fff }
        .btn-danger { background:#ef4444; color:#fff }
        .btn-copy { background:#00d4ff; color:#10203a }

        .job-errors-content { margin-top:12px; max-height:520px; overflow:auto; font-family:monospace; font-size:0.92em; color:#ffdede; white-space:pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç OVH Complaints Tracker</h1>
            <p class="subtitle">Real-time monitoring of domain complaints across social media</p>
            <button onclick="toggleInfo()" style="position: absolute; top: 20px; right: 20px; padding: 8px 15px; background: #0099ff; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-weight: bold;">‚ÑπÔ∏è Info</button>
        </header>

        <!-- Row 1: Filters & Timeline -->
        <div class="controls" style="margin-bottom: 15px; border-bottom: 1px solid rgba(0, 212, 255, 0.2); padding-bottom: 15px;">
            <input type="text" id="searchInput" placeholder="Search posts...">
            
            <select id="languageFilter">
                <option value="">All Languages</option>
                <option value="fr">üá´üá∑ Fran√ßais (French)</option>
                <option value="en">üá¨üáß English</option>
                <option value="other">üåç Other</option>
            </select>
            
            <select id="keywordFilter">
                <option value="">All Keywords</option>
                <optgroup label="Domain Operations">
                    <option value="domain-create">Domain Creation</option>
                    <option value="domain-renew">Domain Renewal</option>
                    <option value="domain-transfer">Domain Transfer</option>
                    <option value="domain-trade">Domain Trade</option>
                    <option value="domain-restore">Domain Restore</option>
                </optgroup>
                <optgroup label="DNS">
                    <option value="dns">DNS Issues</option>
                </optgroup>
            </select>
            
            <input type="date" id="dateFrom" title="From Date">
            <input type="date" id="dateTo" title="To Date">
            <button onclick="applyDateFilter()" class="apply-btn">‚úì Apply Timeline</button>
            
            <select id="sourceFilter">
                <option value="">All Sources</option>
                <option value="X/Twitter">Twitter/X</option>
                <option value="Stack Overflow">Stack Overflow</option>
                <option value="GitHub Issues">GitHub Issues</option>
                <option value="GitHub Discussions">GitHub Discussions</option>
                <option value="Hacker News">Hacker News</option>
                <option value="Google News">Google News</option>
                <option value="Trustpilot">Trustpilot</option>
            </select>
            
            <select id="sentimentFilter">
                <option value="">All Sentiments</option>
                <option value="positive">Positive</option>
                <option value="negative">Negative</option>
                <option value="neutral">Neutral</option>
            </select>
        </div>

        <!-- Keywords manager: let user add up to 10 keywords and persist them -->
        <div class="controls" style="margin-bottom:20px; gap:8px; align-items:center;">
            <input type="text" id="keywordInput" placeholder="Add keyword (press Enter or click +)" style="min-width:220px; max-width:400px;">
            <button onclick="addKeyword()">Ôºã Add</button>
            <label style="font-size:0.9em; color:#ccc;">Limit per scrape:</label>
            <input type="number" id="keywordLimit" min="1" max="500" value="50" style="width:90px;">
            <button onclick="runKeywordSearches()" class="apply-btn">Run keyword searches</button>
            <button onclick="startBackgroundJob()" style="background:#7c3aed;">Start background job</button>
            <button onclick="clearKeywords()" style="background:#ef4444;">Clear keywords</button>
            <div id="keywordsList" style="width:100%; margin-top:10px; display:flex; gap:6px; flex-wrap:wrap;"></div>
            <div id="keywordsSyncIndicator" style="display:none; margin-left:8px; color:#00d4ff; font-size:0.95em; align-items:center;">
                <span class="spinner" aria-hidden="true"></span>
                <span style="margin-left:8px; vertical-align:middle;">Syncing‚Ä¶</span>
            </div>
            <div id="jobPanel" style="display:none; margin-left:12px; color:#fff; font-size:0.95em;">
                <div style="margin-top:8px;">
                    <strong id="jobStatusText">Job: ‚Äî</strong>
                    <div id="jobProgress" style="margin-top:6px; font-size:0.9em; color:#ccc;"></div>
                    <div style="margin-top:6px;">
                        <button id="startJobBtn" onclick="startBackgroundJob()" style="background:#7c3aed;">Start</button>
                        <button id="cancelJobBtn" onclick="cancelBackgroundJob()" style="background:#ef4444;">Cancel Job</button>
                    </div>
                    <div id="jobDetails" style="margin-top:8px; font-size:0.85em; color:#aaa;"></div>
                    <div id="jobErrors" style="margin-top:8px; font-size:0.85em; color:#ffb3b3; display:none; max-height:140px; overflow:auto; border-left:2px solid rgba(239,68,68,0.2); padding-left:8px;"></div>
                    <button id="toggleErrorsBtn" onclick="openJobErrorsModal()" style="margin-top:8px; display:none; background:#ff8b8b;">Voir erreurs d√©taill√©es</button>
                </div>
            </div>
        </div>

        <!-- Row 2: Scraping buttons -->
        <div class="controls" style="margin-bottom: 30px;">
            <button onclick="scrapeX()">Scrape X/Twitter</button>
            <button onclick="scrapeGithub()">Scrape GitHub</button>
            <button onclick="scrapeStackOverflow()">Scrape Stack Overflow</button>
            <button onclick="scrapeHackerNews()">Scrape Hacker News</button>
            <button onclick="scrapeNews()">Scrape Google News</button>
            <button onclick="scrapeTrustpilot()">Scrape Trustpilot</button>
            <button onclick="refreshPosts()">Refresh</button>
            <button id="cancelBtn" onclick="cancelRequest()" style="display:none; background:#ef4444;">Cancel</button>
            <button onclick="toggleBacklog()">üìã Backlog</button>
        </div>

        <div class="stats">
            <div class="stat-card" onclick="filterBySentiment('')">
                <strong id="totalPosts">0</strong>
                <small>Total Posts</small>
            </div>
            <div class="stat-card" onclick="filterBySentiment('positive')">
                <strong id="positivePosts">0</strong>
                <small>Positive</small>
            </div>
            <div class="stat-card" onclick="filterBySentiment('negative')">
                <strong id="negativePosts">0</strong>
                <small>Negative</small>
            </div>
            <div class="stat-card" onclick="filterBySentiment('neutral')">
                <strong id="neutralPosts">0</strong>
                <small>Neutral</small>
            </div>
        </div>

        <div id="logsPanel" style="display:none; margin-bottom:20px;">
            <div class="logs-container" id="logsContainer"></div>
        </div>

        <div id="gallery" class="gallery"></div>

        <div id="backlogPanel" style="display:none; margin-top:40px; padding:20px; background:rgba(15,52,96,0.6); border-radius:12px;">
            <h2 style="margin-bottom:20px;">üìã Backlog (Commentaires Pertinents)</h2>
            <button onclick="clearBacklog()" style="margin-bottom:15px; background:#ef4444;">Clear Backlog</button>
            <button onclick="exportBacklog()" style="margin-bottom:15px;">Export CSV</button>
            <div id="backlogGallery" class="gallery" style="margin-top:20px;"></div>
        </div>

        <div id="infoPanel" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; overflow-y:auto;">
            <div style="max-width:900px; margin:30px auto; background:rgba(26,26,46,0.95); padding:30px; border-radius:12px; border:1px solid rgba(0,212,255,0.3);">
                <button onclick="toggleInfo()" style="float:right; padding:8px 15px; background:#ef4444; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:bold;">‚úï Close</button>
                
                <h1 style="color:#00d4ff; margin-bottom:20px;">‚ÑπÔ∏è Application Info & Disclaimer</h1>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üìñ What is OVH Complaints Tracker?</h2>
                <p style="line-height:1.6; color:#ccc;">
                    OVH Complaints Tracker is a real-time monitoring tool that scrapes social media platforms and news sources 
                    to track complaints and discussions about OVH domain services. The application analyzes sentiment to help 
                    prioritize and understand customer feedback.
                </p>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üåê Data Sources</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px;">
                    <li><strong>Trustpilot</strong> - ‚≠ê Real customer reviews and ratings</li>
                    <li><strong>X (Twitter)</strong> - üí¨ Real-time customer complaints and feedback</li>
                    <li><strong>GitHub Issues</strong> - üìã Customer experience complaints and feature requests</li>
                    <li><strong>Stack Overflow</strong> - ‚ùì Customer technical support questions</li>
                    <li><strong>Hacker News</strong> - üîó Tech community discussions about OVH</li>
                    <li><strong>Google News</strong> - üì∞ News articles and press releases</li>
                </ul>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üîë Search Keywords</h2>
                <p style="line-height:1.6; color:#ccc;">
                    The application automatically searches for the following keywords across all sources:
                </p>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px; background:rgba(0,212,255,0.1); padding:15px; border-radius:6px;">
                    <li><code style="background:#0f3460; padding:4px 8px; border-radius:4px;">"OVH domain"</code></li>
                    <li><code style="background:#0f3460; padding:4px 8px; border-radius:4px;">"OVH complaint"</code></li>
                    <li><code style="background:#0f3460; padding:4px 8px; border-radius:4px;">"OVH support"</code></li>
                </ul>
                <p style="line-height:1.6; color:#ccc; margin-top:15px;">
                    You can also enter custom keywords in the "Scrape" buttons to search for specific terms.
                </p>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">‚öôÔ∏è How It Works</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px;">
                    <li><strong>Manual Scraping:</strong> Click scraper buttons to fetch customer complaints immediately from each source</li>
                    <li><strong>Trustpilot Focus:</strong> Real customer reviews with ratings and sentiment signals</li>
                    <li><strong>X/Twitter Improvement:</strong> Searches complaint keywords (bad support, expensive, overpriced, confusing interface, etc.)</li>
                    <li><strong>GitHub Integration:</strong> Customer experience issues and service feedback, not technical bugs</li>
                    <li><strong>Auto Scraping:</strong> Every 3 hours, automatically collects all customer feedback</li>
                    <li><strong>Sentiment Analysis:</strong> Each post analyzed for negative/positive/neutral sentiment</li>
                    <li><strong>Database Storage:</strong> All posts stored in SQLite for persistent access and analysis</li>
                    <li><strong>Filtering:</strong> Filter by date range, source, sentiment, and custom keywords</li>
                    <li><strong>Backlog:</strong> Save important complaints to your personal backlog for follow-up</li>
                </ul>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üìä Sentiment Analysis</h2>
                <p style="line-height:1.6; color:#ccc;">
                    Posts are classified as:
                </p>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px;">
                    <li><span style="color:#34d399;">‚úì POSITIVE</span> - Satisfactory feedback, positive experiences (score > 0.05)</li>
                    <li><span style="color:#d1d5db;">‚óá NEUTRAL</span> - Factual statements, no clear sentiment (-0.05 to 0.05)</li>
                    <li><span style="color:#ef4444;">‚úó NEGATIVE</span> - Complaints, issues, dissatisfaction (score < -0.05)</li>
                </ul>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üíæ Features</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px;">
                    <li><strong>Timeline Filter:</strong> Select date ranges to analyze posts over time</li>
                    <li><strong>Source Filter:</strong> Focus on specific platforms (X, Reddit, Google News, etc.)</li>
                    <li><strong>Sentiment Filter:</strong> Show only positive, negative, or neutral posts</li>
                    <li><strong>Text Search:</strong> Search for specific keywords within post content</li>
                    <li><strong>Cancel Button:</strong> Stop long-running scraping operations</li>
                    <li><strong>Backlog & Export:</strong> Save posts and export as CSV for further analysis</li>
                </ul>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">‚ö†Ô∏è Limitations & Disclaimer</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px; background:rgba(239,68,68,0.1); padding:15px; border-radius:6px;">
                    <li><strong>Data Limitations:</strong> Scraping is subject to rate limits and may not capture all posts</li>
                    <li><strong>Sentiment Accuracy:</strong> VADER sentiment analysis is statistical and may have false positives</li>
                    <li><strong>Data Privacy:</strong> This tool monitors publicly available social media data only</li>
                    <li><strong>Legal Notice:</strong> Users are responsible for complying with platform ToS and applicable laws</li>
                    <li><strong>Real-time Accuracy:</strong> There may be delays between post creation and indexing (typically < 1 hour)</li>
                </ul>

                <h2 style="color:#ff6b6b; margin-top:30px; margin-bottom:15px;">üö´ Why Some Platforms Are Not Supported</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px; background:rgba(255,107,107,0.1); padding:15px; border-radius:6px;">
                    <li><strong style="color:#ff8787;">‚ùå Reddit:</strong> Uses aggressive anti-scraping (403 Forbidden). Would require OAuth2 authentication and API credentials. Disabled for simplicity.</li>
                    <li><strong style="color:#ff8787;">‚ùå LinkedIn:</strong> Strictly prohibits automated data extraction in Terms of Service. No public API available for posts. Scraping violates legal terms.</li>
                    <li><strong style="color:#ff8787;">‚ùå Facebook:</strong> No public API for accessing posts. Requires special app review by Meta. Data extraction heavily restricted for privacy/security reasons.</li>
                    <li><strong style="color:#34d399;">‚úÖ Supported Instead:</strong> X/Twitter, GitHub Issues, Stack Overflow, Hacker News, Google News - All have public APIs or accessible without authentication</li>
                </ul>

                <h2 style="color:#00d4ff; margin-top:30px; margin-bottom:15px;">üîß Technical Details</h2>
                <ul style="color:#ccc; line-height:1.8; margin-left:20px;">
                    <li><strong>Backend:</strong> FastAPI (Python) with SQLite database</li>
                    <li><strong>Frontend:</strong> Vanilla JavaScript with localStorage for backlog persistence</li>
                    <li><strong>Sentiment:</strong> VADER SentimentIntensityAnalyzer</li>
                    <li><strong>Scheduler:</strong> APScheduler for automated background jobs</li>
                    <li><strong>API Base:</strong> http://127.0.0.1:8000 (adjust if deployed)</li>
                </ul>

                <p style="margin-top:40px; padding-top:20px; border-top:1px solid rgba(0,212,255,0.2); color:#888; font-size:0.9em;">
                    Last updated: January 2026 | For support or issues, check the backend logs
                </p>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://127.0.0.1:8000';

        // LocalStorage for persistent filters
        function saveFilters() {
            const filters = {
                searchInput: document.getElementById('searchInput').value,
                keywordFilter: document.getElementById('keywordFilter').value,
                sourceFilter: document.getElementById('sourceFilter').value,
                sentimentFilter: document.getElementById('sentimentFilter').value,
                dateFrom: document.getElementById('dateFrom').value,
                dateTo: document.getElementById('dateTo').value,
            };
            localStorage.setItem('ovhTrackerFilters', JSON.stringify(filters));
        }

        function loadFilters() {
            const saved = localStorage.getItem('ovhTrackerFilters');
            if (saved) {
                try {
                    const filters = JSON.parse(saved);
                    document.getElementById('searchInput').value = filters.searchInput || '';
                    document.getElementById('keywordFilter').value = filters.keywordFilter || '';
                    document.getElementById('sourceFilter').value = filters.sourceFilter || '';
                    document.getElementById('sentimentFilter').value = filters.sentimentFilter || '';
                    document.getElementById('dateFrom').value = filters.dateFrom || '';
                    document.getElementById('dateTo').value = filters.dateTo || '';
                    console.log('‚úÖ Filters restored from localStorage');
                } catch (e) {
                    console.log('Could not restore filters:', e);
                }
            }
        }

        // Logs management
        let logs = [];
        
        function showLogs() {
            document.getElementById('logsPanel').style.display = 'block';
        }

        function hideLogs() {
            document.getElementById('logsPanel').style.display = 'none';
        }

        function clearLogs() {
            logs = [];
            document.getElementById('logsContainer').innerHTML = '';
        }

        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            const logEntry = {
                timestamp,
                message,
                type
            };
            logs.push(logEntry);
            
            const logsContainer = document.getElementById('logsContainer');
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry ${type}`;
            logDiv.innerHTML = `<span class="log-timestamp">${timestamp}</span>${message}`;
            logsContainer.appendChild(logDiv);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        // Toast notifications
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            let icon = '‚ú®';
            if (type === 'error') icon = '‚ùå';
            if (type === 'info') icon = '‚ÑπÔ∏è';
            
            toast.innerHTML = `${icon} ${message}`;
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.add('hide');
                setTimeout(() => {
                    toast.remove();
                }, 500);
            }, 3000);
        }

        // Mock data for demo
        const mockPosts = [
            {
                id: 1,
                source: 'x',
                author: '@complainingcustomer',
                content: 'OVH domain transfer failed again! Been trying for 3 days. Their support is non-responsive. This is unacceptable!',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T15:30:00',
                sentiment_score: -0.85,
                sentiment_label: 'negative'
            },
            {
                id: 2,
                source: 'reddit',
                author: 'frustrated_user_123',
                content: 'Just experienced a domain renewal issue with OVH. The automatic renewal charge twice. Waiting for refund...',
                url: 'https://reddit.com/r/...',
                created_at: '2026-01-13T14:20:00',
                sentiment_score: -0.72,
                sentiment_label: 'negative'
            },
            {
                id: 3,
                source: 'x',
                author: '@happycustomer',
                content: 'Finally got my OVH domain working smoothly! Customer support helped me out. Great service overall!',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T13:10:00',
                sentiment_score: 0.68,
                sentiment_label: 'positive'
            },
            {
                id: 4,
                source: 'reddit',
                author: 'dev_community',
                content: 'OVH domains are decent but their DNS settings could be clearer in the UI. Not terrible, not amazing.',
                url: 'https://reddit.com/r/...',
                created_at: '2026-01-13T12:00:00',
                sentiment_score: 0.12,
                sentiment_label: 'neutral'
            },
            {
                id: 5,
                source: 'x',
                author: '@techblogger',
                content: 'OVH support response time is getting worse. Their ticketing system is broken. Many customers complaining.',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T11:00:00',
                sentiment_score: -0.78,
                sentiment_label: 'negative'
            },
        ];

        let allPosts = [];
        let currentOffset = 0;
        const postsPerPage = 20;

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        function getSentimentClass(label) {
            return `sentiment sentiment-${label}`;
        }

        function getSourceClass(source) {
            return `post-source source-${source}`;
        }

        function applyDateFilter() {
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;
            
            if (!dateFrom && !dateTo) {
                alert('Please select at least one date');
                return;
            }
            
            if (dateFrom && dateTo && dateFrom > dateTo) {
                alert('Start date must be before end date');
                return;
            }
            
            const fromDisplay = dateFrom ? new Date(dateFrom).toLocaleDateString('fr-FR') : 'any date';
            const toDisplay = dateTo ? new Date(dateTo).toLocaleDateString('fr-FR') : 'today';
            
            addLog(`üìÖ Filtering from ${fromDisplay} to ${toDisplay}`, 'info');
            currentOffset = 0;
            renderGallery();
        }

        function clearAllFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('sourceFilter').value = '';
            document.getElementById('sentimentFilter').value = '';
            document.getElementById('keywordFilter').value = '';
            document.getElementById('languageFilter').value = '';
            document.getElementById('dateFrom').value = '';
            document.getElementById('dateTo').value = '';
            currentOffset = 0;
            addLog('üîÑ All filters cleared', 'info');
            renderGallery();
        }

        function renderGallery() {
            const gallery = document.getElementById('gallery');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const sourceFilter = document.getElementById('sourceFilter').value;
            const sentimentFilter = document.getElementById('sentimentFilter').value;
            const keywordFilter = document.getElementById('keywordFilter').value;
            const languageFilter = document.getElementById('languageFilter').value;
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;

            // Define keyword patterns
            const keywordPatterns = {
                'domain-create': /\b(creat|register|new domain|domaine gratuit|inscription|enregist)\w*/i,
                'domain-renew': /\b(renew|renewal|renouvellement|prolongement|expir|expiration)\w*/i,
                'domain-transfer': /\b(transfer|transf√©r|migration|changement registrar)\w*/i,
                'domain-trade': /\b(trade|trading|√©change|vendre domaine|buy domain|acheter)\w*/i,
                'domain-restore': /\b(restore|restoration|r√©cup√©ration|restore\s+domain)\w*/i,
                'dns': /\b(dns|zone|record|name server|nameserver|propagation|r√©solution)\w*/i,
            };

            let filtered = allPosts.filter(post => {
                const postContent = post.content.toLowerCase();
                const matchesSearch = postContent.includes(searchTerm) || post.author.toLowerCase().includes(searchTerm);
                const matchesSource = !sourceFilter || post.source === sourceFilter;
                const matchesSentiment = !sentimentFilter || post.sentiment_label === sentimentFilter;
                const matchesLanguage = !languageFilter || post.language === languageFilter;
                
                // Keyword filter
                let matchesKeyword = true;
                if (keywordFilter && keywordPatterns[keywordFilter]) {
                    matchesKeyword = keywordPatterns[keywordFilter].test(post.content);
                }
                
                // Date range filter
                let matchesDate = true;
                if (dateFrom || dateTo) {
                    const postDate = new Date(post.created_at).toISOString().split('T')[0];
                    if (dateFrom && postDate < dateFrom) matchesDate = false;
                    if (dateTo && postDate > dateTo) matchesDate = false;
                }
                
                return matchesSearch && matchesSource && matchesSentiment && matchesKeyword && matchesDate && matchesLanguage;
            });

            // Debug log to track filtering
            if (allPosts.length !== filtered.length) {
                console.log(`[FILTER] ${allPosts.length} total posts -> ${filtered.length} after filters`, {
                    search: searchTerm || 'none',
                    source: sourceFilter || 'all',
                    sentiment: sentimentFilter || 'all',
                    keyword: keywordFilter || 'all',
                    language: languageFilter || 'all',
                    dateRange: (dateFrom || dateTo) ? `${dateFrom || '*'} to ${dateTo || '*'}` : 'all'
                });
            }

            updateStats(filtered);

            if (filtered.length === 0) {
                const activeFilters = [];
                if (searchTerm) activeFilters.push(`Search: "${searchTerm}"`);
                if (sourceFilter) activeFilters.push(`Source: ${sourceFilter}`);
                if (sentimentFilter) activeFilters.push(`Sentiment: ${sentimentFilter}`);
                if (keywordFilter) activeFilters.push(`Keyword: ${keywordFilter}`);
                if (languageFilter) activeFilters.push(`Language: ${languageFilter}`);
                if (dateFrom || dateTo) activeFilters.push(`Date: ${dateFrom || '*'} to ${dateTo || '*'}`);
                
                const filterInfo = activeFilters.length > 0 
                    ? `<p style="color:#ff9800;">Active filters hiding ${allPosts.length} posts:</p><ul style="text-align:left; max-width:500px; margin:15px auto;">${activeFilters.map(f => `<li>${f}</li>`).join('')}</ul><button onclick="clearAllFilters()" style="margin-top:15px; padding:12px 24px; background:#00d4ff; border:none; border-radius:8px; color:#1a1a2e; font-weight:bold; cursor:pointer;">Clear all filters</button>`
                    : `<p>Try scraping data or adjusting your filters.</p>`;
                
                gallery.innerHTML = `<div class="empty-state"><h2>No posts found</h2>${filterInfo}</div>`;
                return;
            }

            // Pagination
            const totalPosts = filtered.length;
            const paginated = filtered.slice(currentOffset, currentOffset + postsPerPage);

            gallery.innerHTML = paginated.map(post => {
                // Detect sample/demo data
                const isSample = post.url && (post.url.includes('/sample') || post.url.includes('/status/174'));
                return `
                <div class="post-card">
                    <div class="post-header">
                        <span class="${getSourceClass(post.source)}">${post.source}</span>
                        <span class="post-date">${formatDate(post.created_at)}</span>
                        ${post.language ? `<span style="font-size:0.75em; background:rgba(0,212,255,0.2); padding:4px 8px; border-radius:4px; margin-left:5px;">${post.language.toUpperCase()}</span>` : ''}
                        ${isSample ? `<span style="font-size:0.7em; background:rgba(255,152,0,0.3); padding:3px 8px; border-radius:4px; margin-left:5px; border:1px solid rgba(255,152,0,0.5);" title="Demo data - scraper returned fallback sample">üìã SAMPLE</span>` : ''}
                    </div>
                    <div class="post-author">@${post.author}</div>
                    <div class="post-content">${post.content}</div>
                    <div class="post-footer">
                        <span class="${getSentimentClass(post.sentiment_label)}">
                            ${post.sentiment_label.toUpperCase()} (${(post.sentiment_score).toFixed(2)})
                        </span>
                        <a href="${post.url}" target="_blank" class="post-url" ${isSample ? 'onclick="alert(\'This is sample data. Real scraper APIs require authentication keys.\'); return false;"' : ''}>View</a>
                        <button onclick="addToBacklog(${post.id})" style="margin-left:10px; padding:6px 12px; background:#0099ff; border:none; border-radius:6px; color:#fff; cursor:pointer;">Save</button>
                    </div>
                </div>
            `}).join('');

            // Add load more button if there are more posts
            if (currentOffset + postsPerPage < totalPosts) {
                const loadMoreDiv = document.createElement('div');
                loadMoreDiv.style.textAlign = 'center';
                loadMoreDiv.style.marginTop = '30px';
                loadMoreDiv.style.gridColumn = '1 / -1';
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.onclick = loadMorePosts;
                loadMoreBtn.style.padding = '12px 30px';
                loadMoreBtn.style.background = '#00d4ff';
                loadMoreBtn.style.color = '#1a1a2e';
                loadMoreBtn.style.border = 'none';
                loadMoreBtn.style.borderRadius = '8px';
                loadMoreBtn.style.cursor = 'pointer';
                loadMoreBtn.style.fontWeight = 'bold';
                loadMoreBtn.style.fontSize = '1em';
                loadMoreBtn.textContent = `üì• Load More (${currentOffset + postsPerPage}/${totalPosts})`;
                loadMoreDiv.appendChild(loadMoreBtn);
                gallery.appendChild(loadMoreDiv);
            }
        }

        function loadMorePosts() {
            currentOffset += postsPerPage;
            renderGallery();
        }

        function updateStats(posts) {
            const total = posts.length;
            const positive = posts.filter(p => p.sentiment_label === 'positive').length;
            const negative = posts.filter(p => p.sentiment_label === 'negative').length;
            const neutral = posts.filter(p => p.sentiment_label === 'neutral').length;

            document.getElementById('totalPosts').textContent = total;
            document.getElementById('positivePosts').textContent = positive;
            document.getElementById('negativePosts').textContent = negative;
            document.getElementById('neutralPosts').textContent = neutral;
        }

        function filterBySentiment(sentiment) {
            document.getElementById('sentimentFilter').value = sentiment;
            currentOffset = 0;
            saveFilters();
            renderGallery();
            addLog(`üîç Filtering by sentiment: ${sentiment || 'All'}`, 'info');
        }

        // Abort controller for canceling requests
        let currentAbortController = null;

        function showCancelBtn(show) {
            const cancelBtn = document.getElementById('cancelBtn');
            if (cancelBtn) {
                cancelBtn.style.display = show ? 'inline-block' : 'none';
            }
        }

        async function cancelScrape() {
            if (currentAbortController) {
                currentAbortController.abort();
                addLog('‚õî Canceling scrape operation...', 'info');
            }
        }

        async function refreshPosts() {
            try {
                const response = await fetch(`${API_BASE}/posts?limit=1000&offset=0`);
                const data = await response.json();
                if (response.ok) {
                    const previousCount = allPosts.length;
                    allPosts = data;
                    currentOffset = 0;
                    renderGallery();
                    addLog(`‚úÖ Loaded ${data.length} posts from database (${data.length - previousCount > 0 ? '+' + (data.length - previousCount) + ' new' : 'no change'})`, 'success');
                } else {
                    addLog('‚ùå Failed to load posts', 'error');
                }
            } catch (e) {
                addLog(`‚ùå Error loading posts: ${e.message}`, 'error');
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeX() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting X/Twitter scraper...', 'info');
            addLog(`üìù Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/x?query=${encodeURIComponent(combinedQuery)}&limit=50`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} posts from X/Twitter`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping X: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeStackOverflow() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Stack Overflow scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/stackoverflow?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} questions from Stack Overflow`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping Stack Overflow: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeNews() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Google News scraper...', 'info');
            addLog(`üì∞ Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/news?query=${encodeURIComponent(combinedQuery)}&limit=50`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} articles from Google News`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping News: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeHackerNews() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Hacker News scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/hackernews?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} discussions from Hacker News`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping Hacker News: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeGithub() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting GitHub Issues scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/github?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} issues/discussions from GitHub`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping GitHub: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }


        async function scrapeTrustpilot() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured - using default "OVH"', 'info');
                keywords = ['OVH'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Trustpilot scraper...', 'info');
            addLog(`‚≠ê Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/trustpilot?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} reviews from Trustpilot`, 'success');
                    await refreshPosts();
                } else {
                    addLog(`‚ùå Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Scrape cancelled by user', 'error');
                } else {
                    addLog(`‚ùå Error scraping Trustpilot: ${e.message}`, 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function refreshPosts() {
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Refreshing posts...', 'info');
            
            try {
                const response = await fetch(`${API_BASE}/posts?limit=100`, {
                    signal: currentAbortController.signal
                });
                if (response.ok) {
                    allPosts = await response.json();
                    addLog(`‚úÖ Loaded ${allPosts.length} posts from database`, 'success');
                } else {
                    addLog('Using mock data (API not available)', 'error');
                    allPosts = [...mockPosts];
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Refresh cancelled by user', 'error');
                } else {
                    addLog('API not available, using mock data', 'error');
                    allPosts = [...mockPosts];
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
                renderGallery();
            }
        }

        // Backlog functions
        function loadBacklog() {
            const saved = localStorage.getItem('ovh_backlog');
            return saved ? JSON.parse(saved) : [];
        }

        function saveBacklog(backlog) {
            localStorage.setItem('ovh_backlog', JSON.stringify(backlog));
        }

        function addToBacklog(postId) {
            const post = allPosts.find(p => p.id === postId);
            if (!post) return;

            const backlog = loadBacklog();
            if (!backlog.find(p => p.id === postId)) {
                backlog.push(post);
                saveBacklog(backlog);
                const preview = post.content.substring(0, 45) + (post.content.length > 45 ? '...' : '');
                showToast(`Saved: "${preview}"`, 'success');
            } else {
                showToast('This post is already in the backlog', 'error');
            }
        }

        function toggleBacklog() {
            const panel = document.getElementById('backlogPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                renderBacklog();
            } else {
                panel.style.display = 'none';
            }
        }

        function renderBacklog() {
            const backlog = loadBacklog();
            const backlogGallery = document.getElementById('backlogGallery');

            if (backlog.length === 0) {
                backlogGallery.innerHTML = '<div class="empty-state"><p>No posts in backlog yet</p></div>';
                return;
            }

            backlogGallery.innerHTML = backlog.map(post => `
                <div class="post-card">
                    <div class="post-header">
                        <span class="${getSourceClass(post.source)}">${post.source}</span>
                        <span class="post-date">${formatDate(post.created_at)}</span>
                    </div>
                    <div class="post-author">@${post.author}</div>
                    <div class="post-content">${post.content}</div>
                    <div class="post-footer">
                        <span class="${getSentimentClass(post.sentiment_label)}">
                            ${post.sentiment_label.toUpperCase()} (${(post.sentiment_score).toFixed(2)})
                        </span>
                        <a href="${post.url}" target="_blank" class="post-url">View</a>
                        <button onclick="removeFromBacklog(${post.id})" style="margin-left:10px; padding:6px 12px; background:#ef4444; border:none; border-radius:6px; color:#fff; cursor:pointer;">Remove</button>
                    </div>
                </div>
            `).join('');
        }

        function removeFromBacklog(postId) {
            let backlog = loadBacklog();
            backlog = backlog.filter(p => p.id !== postId);
            saveBacklog(backlog);
            renderBacklog();
            console.log(`Post ${postId} removed from backlog`);
        }

        function clearBacklog() {
            if (confirm('Are you sure you want to clear the entire backlog?')) {
                localStorage.removeItem('ovh_backlog');
                renderBacklog();
                console.log('Backlog cleared');
            }
        }

        function exportBacklog() {
            const backlog = loadBacklog();
            if (backlog.length === 0) {
                alert('Backlog is empty');
                return;
            }

            const csv = [
                ['ID', 'Source', 'Author', 'Content', 'URL', 'Date', 'Sentiment', 'Score'],
                ...backlog.map(p => [
                    p.id,
                    p.source,
                    p.author,
                    p.content.replace(/"/g, '""'),
                    p.url,
                    p.created_at,
                    p.sentiment_label,
                    p.sentiment_score
                ])
            ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ovh-backlog-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function toggleInfo() {
            const panel = document.getElementById('infoPanel');
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                console.log('‚úÖ Info panel opened');
            } else {
                panel.style.display = 'none';
                console.log('‚úÖ Info panel closed');
            }
        }

        // Close info panel when clicking outside
        document.addEventListener('click', (e) => {
            const infoPanel = document.getElementById('infoPanel');
            if (infoPanel && infoPanel.style.display === 'block' && e.target === infoPanel) {
                infoPanel.style.display = 'none';
            }
        });

        // Event listeners with filter saving
        const filterElements = ['searchInput', 'sourceFilter', 'sentimentFilter', 'keywordFilter', 'dateFrom', 'dateTo'];
        
        filterElements.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', () => { saveFilters(); renderGallery(); });
                el.addEventListener('change', () => { saveFilters(); renderGallery(); });
            }
        });

        // Load filters and render
        loadFilters();
        renderGallery();

        // --- Keywords manager: persist and run searches ---
        function loadKeywords() {
            const saved = localStorage.getItem('ovh_queries');
            return saved ? JSON.parse(saved) : [];
        }

        function saveKeywords(keywords) {
            localStorage.setItem('ovh_queries', JSON.stringify(keywords));
            // attempt to sync to server (fire-and-forget)
            syncKeywordsToServer(keywords).catch(err => {
                console.warn('Could not sync keywords to server:', err);
            });
        }

        function renderKeywords() {
            const list = document.getElementById('keywordsList');
            const keywords = loadKeywords();
            list.innerHTML = '';
            keywords.forEach((kw, idx) => {
                const chip = document.createElement('div');
                chip.style.padding = '6px 10px';
                chip.style.background = 'rgba(0,212,255,0.08)';
                chip.style.border = '1px solid rgba(0,212,255,0.12)';
                chip.style.borderRadius = '16px';
                chip.style.color = '#00d4ff';
                chip.style.fontSize = '0.9em';
                chip.textContent = kw;
                const rem = document.createElement('button');
                rem.textContent = '‚úï';
                rem.style.marginLeft = '8px';
                rem.style.background = 'transparent';
                rem.style.border = 'none';
                rem.style.color = '#ff9b9b';
                rem.style.cursor = 'pointer';
                rem.onclick = () => { removeKeyword(idx); };
                chip.appendChild(rem);
                list.appendChild(chip);
            });
            if (keywords.length === 0) {
                list.innerHTML = '<small style="color:#aaa;">No keywords defined ‚Äî add some to start searches.</small>';
            }
        }

        function addKeyword() {
            const input = document.getElementById('keywordInput');
            const value = (input.value || '').trim();
            if (!value) return;
            let keywords = loadKeywords();
            if (keywords.length >= 10) { showToast('Max 10 keywords allowed', 'error'); return; }
            if (keywords.includes(value)) { showToast('Keyword already added', 'error'); input.value = ''; return; }
            keywords.push(value);
            saveKeywords(keywords);
            input.value = '';
            renderKeywords();
            showToast(`Added keyword: ${value}`, 'success');
        }

        function removeKeyword(index) {
            let keywords = loadKeywords();
            if (index < 0 || index >= keywords.length) return;
            const removed = keywords.splice(index,1)[0];
            saveKeywords(keywords);
            renderKeywords();
            showToast(`Removed: ${removed}`, 'info');
        }

        function clearKeywords() {
            if (!confirm('Clear all saved keywords?')) return;
            localStorage.removeItem('ovh_queries');
            // also clear on server
            saveKeywords([]);
            renderKeywords();
            showToast('Keywords cleared', 'success');
        }

        // Sync functions with backend
        async function syncKeywordsToServer(keywords) {
            showSyncIndicator(true);
            addLog('üîÅ Syncing keywords to server...', 'info');
            try {
                const resp = await fetch(`${API_BASE}/settings/queries`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keywords })
                });
                if (!resp.ok) {
                    const txt = await resp.text();
                    showToast(`Server sync failed: ${txt}`, 'error');
                    addLog(`‚ùå Server sync failed: ${txt}`, 'error');
                    console.warn('Server sync failed', txt);
                } else {
                    showToast('Keywords synced to server', 'info');
                    addLog('‚úÖ Keywords synced to server', 'success');
                }
            } catch (e) {
                console.warn('syncKeywordsToServer error', e);
                showToast('Network error: could not sync keywords', 'error');
                addLog(`‚ùå Network error during keywords sync: ${e.message || e}`, 'error');
            } finally {
                showSyncIndicator(false);
            }
        }

        async function loadKeywordsFromServer() {
            showSyncIndicator(true);
            try {
                const resp = await fetch(`${API_BASE}/settings/queries`);
                if (!resp.ok) return renderKeywords();
                const data = await resp.json();
                if (data && Array.isArray(data.keywords) && data.keywords.length > 0) {
                    // overwrite local keywords with server list without re-syncing
                    localStorage.setItem('ovh_queries', JSON.stringify(data.keywords));
                    addLog('‚úÖ Loaded keywords from server', 'success');
                }
            } catch (e) {
                console.warn('Could not load keywords from server', e);
                addLog('‚ùå Could not load keywords from server', 'error');
            } finally {
                showSyncIndicator(false);
                renderKeywords();
            }
        }

        function showSyncIndicator(show) {
            const el = document.getElementById('keywordsSyncIndicator');
            if (!el) return;
            el.style.display = show ? 'inline-block' : 'none';
        }

        async function runKeywordSearches() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                showToast('No keywords to search', 'error');
                return;
            }

            const limit = Math.max(1, Math.min(500, Number(document.getElementById('keywordLimit').value || 50)));
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();

            addLog(`üîé Running searches for ${keywords.length} keywords (limit=${limit})`, 'info');

            const sources = ['x','github','stackoverflow','hackernews','news','trustpilot'];

            try {
                for (const kw of keywords) {
                    addLog(`‚û°Ô∏è Keyword: "${kw}"`, 'info');
                    for (const s of sources) {
                        const url = `${API_BASE}/scrape/${s}?query=${encodeURIComponent(kw)}&limit=${limit}`;
                        addLog(`   ‚Ä¢ Calling ${s}...`, 'info');
                        try {
                            const resp = await fetch(url, { method: 'POST', signal: currentAbortController.signal });
                            if (resp.ok) {
                                const data = await resp.json();
                                addLog(`   ‚úì ${s}: added ${data.added}`, 'success');
                            } else {
                                const txt = await resp.text();
                                addLog(`   ‚úó ${s} error: ${txt}`, 'error');
                            }
                        } catch (e) {
                            if (e.name === 'AbortError') {
                                addLog('‚õî Operation aborted', 'error');
                                throw e;
                            } else {
                                addLog(`   ‚úó ${s} fetch failed: ${e.message}`, 'error');
                            }
                        }
                    }
                    // refresh posts after each keyword
                    await refreshPosts();
                }
                showToast('Keyword searches completed', 'success');
            } catch (e) {
                if (e.name === 'AbortError') {
                    showToast('Searches cancelled', 'error');
                } else {
                    showToast('Error during searches', 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        // wire Enter key to add keyword
        document.getElementById('keywordInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); addKeyword(); }
        });

        // Render saved keywords on load
        renderKeywords();

        // Job polling / background job UI
        let jobPollInterval = null;

        function persistLastJob(jobId) {
            if (!jobId) return localStorage.removeItem('ovh_last_job');
            localStorage.setItem('ovh_last_job', jobId);
        }

        function loadLastJob() {
            return localStorage.getItem('ovh_last_job');
        }

        async function startBackgroundJob() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) { showToast('No keywords to start job', 'error'); return; }
            const limit = Math.max(1, Math.min(500, Number(document.getElementById('keywordLimit').value || 50)));
            const concurrency = 2;
            const delay = 0.5;

            addLog('üöÄ Starting background job for keywords...', 'info');
            showLogs();
            try {
                const resp = await fetch(`${API_BASE}/scrape/keywords?limit=${limit}&concurrency=${concurrency}&delay=${delay}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keywords })
                });
                if (!resp.ok) {
                    const txt = await resp.text();
                    addLog(`‚ùå Failed to start background job: ${txt}`, 'error');
                    showToast('Failed to start job', 'error');
                    return;
                }
                const data = await resp.json();
                const jobId = data.job_id || data.jobId || data.id;
                if (!jobId) {
                    addLog('‚ùå No job id returned from server', 'error');
                    showToast('Server did not return job id', 'error');
                    return;
                }
                persistLastJob(jobId);
                addLog(`‚úÖ Background job started: ${jobId}`, 'success');
                document.getElementById('jobPanel').style.display = 'block';
                updateJobPanel({ id: jobId, status: 'pending', progress: { total: 0, completed: 0 } });
                // start polling
                if (jobPollInterval) clearInterval(jobPollInterval);
                jobPollInterval = setInterval(() => pollJobStatus(jobId), 2000);
                // immediate poll
                pollJobStatus(jobId);
            } catch (e) {
                addLog(`‚ùå Error starting background job: ${e.message}`, 'error');
                showToast('Network error starting job', 'error');
            }
        }

        async function pollJobStatus(jobId) {
            try {
                const resp = await fetch(`${API_BASE}/scrape/jobs/${encodeURIComponent(jobId)}`);
                if (!resp.ok) {
                    addLog(`‚ùå Could not fetch job ${jobId}: ${resp.statusText}`, 'error');
                    return;
                }
                const status = await resp.json();
                updateJobPanel(status);
                if (status.status === 'completed' || status.status === 'failed' || status.status === 'cancelled') {
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    persistLastJob(null);
                    showToast(`Job ${status.status}`, status.status === 'completed' ? 'success' : 'error');
                }
            } catch (e) {
                addLog(`‚ùå Error polling job: ${e.message}`, 'error');
            }
        }

        function updateJobPanel(status) {
            const statusText = document.getElementById('jobStatusText');
            const jobProgress = document.getElementById('jobProgress');
            const jobDetails = document.getElementById('jobDetails');
            if (!statusText || !jobProgress || !jobDetails) return;
            statusText.textContent = `Job: ${status.id || '‚Äì'} ‚Äî ${status.status || 'unknown'}`;
            const total = (status.progress && status.progress.total) || 0;
            const completed = (status.progress && status.progress.completed) || 0;
            jobProgress.innerHTML = `Progress: ${completed} / ${total}`;
            const results = Array.isArray(status.results) ? status.results.length : (status.results && status.results.length) || 0;
            const errors = Array.isArray(status.errors) ? status.errors.length : (status.errors && status.errors.length) || 0;
            jobDetails.innerHTML = `ID: ${status.id || '‚Äì'} <br> Results entries: ${results} ‚Ä¢ Errors: ${errors} <br> Updated: ${status.updated_at || ''}`;
            // also push some log lines for visibility
            if (status.results && status.results.length > 0) {
                const last = status.results[status.results.length-1];
                addLog(`üîî Task result: ${JSON.stringify(last)}`, 'info');
            }
            const jobErrorsEl = document.getElementById('jobErrors');
            const toggleBtn = document.getElementById('toggleErrorsBtn');
            if (status.errors && status.errors.length > 0) {
                const lastE = status.errors[status.errors.length-1];
                addLog(`‚ö†Ô∏è Task error: ${lastE}`, 'error');
                if (jobErrorsEl) {
                    jobErrorsEl.style.display = 'block';
                    jobErrorsEl.innerHTML = status.errors.map(e => `<div style="margin-bottom:6px;">${e}</div>`).join('');
                }
                if (toggleBtn) toggleBtn.style.display = 'inline-block';
            } else {
                if (jobErrorsEl) {
                    jobErrorsEl.style.display = 'none';
                    jobErrorsEl.innerHTML = '';
                }
                if (toggleBtn) toggleBtn.style.display = 'none';
            }
        }

        function toggleJobErrors() {
            const el = document.getElementById('jobErrors');
            if (!el) return;
            el.style.display = (el.style.display === 'block') ? 'none' : 'block';
        }

        async function cancelBackgroundJob() {
            const jobId = loadLastJob();
            if (!jobId) {
                showToast('No active job to cancel', 'error');
                return;
            }
            try {
                const resp = await fetch(`${API_BASE}/scrape/jobs/${encodeURIComponent(jobId)}/cancel`, { method: 'POST' });
                if (resp.ok) {
                    addLog(`üõë Cancel requested for job ${jobId}`, 'info');
                    persistLastJob(null);
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    document.getElementById('jobPanel').style.display = 'none';
                    showToast('Job cancellation requested', 'info');
                } else {
                    const txt = await resp.text();
                    addLog(`‚ùå Cancel failed: ${txt}`, 'error');
                    showToast('Cancel failed', 'error');
                }
            } catch (e) {
                addLog(`‚ùå Error cancelling job: ${e.message}`, 'error');
                showToast('Network error cancelling job', 'error');
            }
        }

        // On load, if there's a recent job, resume polling
        (function resumeLastJob() {
            const last = loadLastJob();
            if (last) {
                document.getElementById('jobPanel').style.display = 'block';
                jobPollInterval = setInterval(() => pollJobStatus(last), 2000);
                pollJobStatus(last);
            }
        })();

        // --- Job Errors Modal ---
        // Create modal HTML dynamically and attach to body
        (function createJobErrorsModal(){
            const overlay = document.createElement('div');
            overlay.id = 'jobErrorsModal';
            overlay.className = 'job-errors-modal-overlay';
            overlay.innerHTML = `
                <div class="job-errors-modal" role="dialog" aria-modal="true">
                    <div class="job-errors-header">
                        <h3 class="job-errors-title">Erreurs du job</h3>
                        <div class="job-errors-actions">
                            <button id="copyErrorsBtn" class="btn btn-copy">Copier</button>
                            <button id="downloadErrorsBtn" class="btn btn-ghost">T√©l√©charger</button>
                            <button id="closeErrorsBtn" class="btn btn-danger">Fermer</button>
                        </div>
                    </div>
                    <div id="jobErrorsContent" class="job-errors-content"></div>
                </div>
            `;
            document.body.appendChild(overlay);

            // close handlers
            document.getElementById('closeErrorsBtn').onclick = () => { overlay.style.display='none'; };
            overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display='none'; });

            document.getElementById('copyErrorsBtn').onclick = async () => {
                const txt = document.getElementById('jobErrorsContent').innerText;
                try { await navigator.clipboard.writeText(txt); showToast('Erreurs copi√©es', 'info'); } catch(e){ showToast('Impossible de copier', 'error'); }
            };

            document.getElementById('downloadErrorsBtn').onclick = () => {
                const txt = document.getElementById('jobErrorsContent').innerText;
                const blob = new Blob([txt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `job-errors-${new Date().toISOString()}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            };
        })();

        function openJobErrorsModal() {
            const overlay = document.getElementById('jobErrorsModal');
            const content = document.getElementById('jobErrorsContent');
            const jobErrorsEl = document.getElementById('jobErrors');
            if (!overlay || !content) return;
            content.innerText = jobErrorsEl ? jobErrorsEl.innerText : 'Aucune erreur.';
            overlay.style.display = 'flex';
        }
    </script>
</body>
</html>

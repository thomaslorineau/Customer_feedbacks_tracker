<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Feedbacks Tracker - Feedbacks Collection</title>
    <link rel="stylesheet" href="/css/shared-theme.css">
    <link rel="stylesheet" href="/dashboard/css/navigation.css">
    <link rel="stylesheet" href="/css/modern-enhancements.css">
    <style>
        :root {
            /* Light Mode (default - matching V2) */
            --bg-primary: #ffffff;
            --bg-secondary: #f5f7fa;
            --bg-card: #ffffff;
            --bg-card-hover: #f0f4f8;
            --text-primary: #1a1a1a;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            --border-color: #e2e8f0;
            --shadow: rgba(0, 0, 0, 0.08);
            --accent-primary: #0099ff;
            --accent-secondary: #00d4ff;
            --accent-ovh: #123f6d;
            --success: #34d399;
            --warning: #f59e0b;
            --error: #ef4444;
            --input-bg: #ffffff;
            --modal-bg: rgba(255, 255, 255, 0.98);
        }

        body.dark-mode {
            /* Dark Mode */
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --bg-card-hover: #1a4d7a;
            --text-primary: #ffffff;
            --text-secondary: #aaa;
            --text-muted: #666;
            --border-color: #333;
            --shadow: rgba(0, 0, 0, 0.3);
            --accent-primary: #00d4ff;
            --accent-secondary: #0099ff;
            --accent-ovh: #4a9eff;
            --success: #34d399;
            --warning: #f59e0b;
            --error: #ef4444;
            --input-bg: #0f3460;
            --modal-bg: rgba(15, 52, 96, 0.98);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            padding: 30px 40px;
            margin: -20px -20px 40px -20px;
            box-shadow: 0 2px 8px var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .header-logo-container {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .ovh-logo-main {
            width: 60px;
            height: 60px;
        }

        .ovh-logo-main svg {
            width: 100%;
            height: 100%;
        }

        .header-title-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        h1 {
            font-size: 2.2em;
            margin: 0;
            color: var(--text-primary);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .ovh-logo-text {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--accent-ovh);
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1em;
            margin: 0;
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1.2em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        /* Override fixed position when inside nav-menu-right */
        .nav-menu-right .theme-toggle {
            position: static;
            top: auto;
            right: auto;
            box-shadow: none;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px var(--shadow);
        }

        .version-toggle {
            position: fixed;
            top: 20px;
            right: 80px;
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow);
            color: var(--text-primary);
            font-weight: bold;
        }

        /* Override fixed position when inside nav-menu-right */
        .nav-menu-right .version-badge {
            position: static;
            top: auto;
            right: auto;
            box-shadow: none;
        }

        .version-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px var(--shadow);
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .version-badge {
            padding: 4px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: default;
            user-select: none;
        }

        .version-badge:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .version-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .version-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .info-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 15px;
            background: var(--accent-secondary);
            border: none;
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 999;
        }

        .info-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls button, .controls select, .controls input {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .controls input {
            flex: 1;
            min-width: 200px;
            max-width: 300px;
        }

        .controls button:hover, .controls select:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .controls button:focus {
            outline: none;
        }

        .apply-btn {
            background: var(--accent-primary);
            color: white;
            font-weight: bold;
        }

        .apply-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 153, 255, 0.3);
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stat-card {
            background: var(--bg-card);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .stat-card:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .stat-card strong {
            display: block;
            font-size: 1.8em;
            color: var(--accent-primary);
            margin-bottom: 5px;
        }

        .stat-card small {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .post-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 2px 8px var(--shadow);
            position: relative;
            overflow: visible;
            width: 100%;
            min-height: 200px;
        }

        .post-card:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
            transform: translateY(-5px);
            z-index: 10;
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .post-source {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .source-x {
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-primary);
        }

        .source-reddit {
            background: rgba(255, 69, 0, 0.6);
            color: var(--text-primary);
        }

        .source-linkedin {
            background: rgba(0, 119, 181, 0.6);
            color: var(--text-primary);
        }

        .source-facebook {
            background: rgba(59, 89, 152, 0.6);
            color: var(--text-primary);
        }

        .post-date {
            color: var(--text-muted);
            font-size: 0.85em;
        }

        .post-author {
            color: var(--accent-primary);
            font-weight: bold;
            font-size: 0.95em;
        }

        .post-content {
            color: var(--text-secondary);
            line-height: 1.6;
            flex-grow: 1;
            max-height: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 212, 255, 0.1);
        }

        .sentiment {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .sentiment-positive {
            background: rgba(52, 211, 153, 0.3);
            color: #34d399;
        }

        .sentiment-negative {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .sentiment-neutral {
            background: rgba(107, 114, 128, 0.3);
            color: #d1d5db;
        }

        .post-url {
            color: var(--accent-secondary);
            text-decoration: none;
            font-size: 0.85em;
            word-break: break-all;
            font-weight: 500;
        }

        .post-url:hover {
            text-decoration: underline;
            color: var(--accent-primary);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state h2 {
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .loader {
            text-align: center;
            padding: 40px;
            color: var(--accent-primary);
        }

        .loader span {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-primary);
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loader span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loader span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                opacity: 0.3;
                transform: scale(0);
            }
            40% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .logs-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }
        
        .logs-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .logs-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .logs-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .logs-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .log-entry {
            margin-bottom: 6px;
            padding: 10px 15px;
            border-left: 4px solid var(--accent-primary);
            padding-left: 15px;
            background: var(--bg-card);
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: var(--bg-card-hover);
            transform: translateX(2px);
        }

        .log-entry.success {
            color: #34d399;
            border-left-color: #34d399;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, #34d399, #10b981);
            color: var(--text-primary);
            padding: 18px 28px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(52, 211, 153, 0.4);
            font-size: 0.95em;
            font-weight: 500;
            animation: slideIn 0.5s ease-out;
            z-index: 9999;
            border-left: 4px solid #fff;
            max-width: 400px;
        }

        .toast.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
        }

        .toast.info {
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
        }

        @keyframes slideIn {
            from {
                transform: translateX(500px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(500px);
                opacity: 0;
            }
        }

        .toast.hide {
            animation: slideOut 0.5s ease-out forwards;
        }

        .log-entry.error {
            color: #ef4444;
            border-left-color: #ef4444;
        }

        .log-entry.info {
            color: var(--accent-primary);
            border-left-color: var(--accent-primary);
        }

        .log-timestamp {
            color: var(--text-muted);
            font-size: 0.8em;
            margin-right: 8px;
        }

        /* Light mode support for logs and modals */
        body.light-mode .logs-container {
            background: rgba(255, 255, 255, 0.95);
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        body.light-mode .log-entry {
            border-left-color: var(--accent-primary);
            color: var(--text-primary);
        }

        body.light-mode .log-entry.success {
            color: #10b981;
        }

        body.light-mode .log-entry.error {
            color: #dc2626;
        }

        body.light-mode .log-entry.info {
            color: var(--accent-primary);
        }

        body.light-mode .log-timestamp {
            color: var(--text-muted);
        }

        /* Modal styles using CSS variables */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.85);
        }

        body.light-mode .modal-overlay {
            background: rgba(0, 0, 0, 0.6);
        }

        .modal-content {
            background: var(--modal-bg);
            color: var(--text-primary);
        }

        body.light-mode .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f5f7fa 100%);
        }

        /* Chart modal specific */
        .chart-modal-bg {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }

        body.light-mode .chart-modal-bg {
            background: linear-gradient(135deg, #ffffff 0%, #f5f7fa 100%);
        }

        /* Job errors modal light mode */
        body.light-mode .job-errors-modal {
            background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(248,250,252,0.98));
            color: var(--text-primary);
        }

        body.light-mode .job-errors-content {
            color: #7f1d1d;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.15);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
            animation: spin 1s linear infinite;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: var(--bg-card);
            border-radius: 8px;
        }

        .sort-controls label {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .filter-count {
            display: inline-block;
            background: var(--accent-primary);
            color: #1a1a2e;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 8px;
        }

        /* Job errors modal styles */
        .job-errors-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .job-errors-modal {
            width: 100%;
            max-width: 980px;
            background: linear-gradient(180deg, rgba(22,22,34,0.98), rgba(18,18,28,0.98));
            border-radius: 12px;
            border: 1px solid rgba(239,68,68,0.12);
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            color: var(--text-primary);
            padding: 18px;
        }

        .job-errors-header { display:flex; align-items:center; justify-content:space-between; gap:12px }
        .job-errors-title { color:#ffb3b3; margin:0; font-size:1.1em }
        .job-errors-actions button { margin-left:8px; }

        .btn { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:600 }
        .btn-ghost { background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.06) }
        .btn-primary { background:#7c3aed; color:#fff }
        .btn-danger { background:#ef4444; color:#fff }
        .btn-copy { background:#00d4ff; color:#10203a }

        .job-errors-content { margin-top:12px; max-height:520px; overflow:auto; font-family:monospace; font-size:0.92em; color:#ffdede; white-space:pre-wrap; }
    </style>
</head>
<body class="v1-page">
    <!-- Navigation Menu -->
    <nav class="nav-menu">
        <div class="nav-menu-left">
            <a href="/scraping" class="nav-logo">
                <img src="/assets/logo/ovhcloud-logo.svg" alt="OVHcloud" class="ovh-logo" style="width: 40px; height: 40px; object-fit: contain; filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <svg class="ovh-logo" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                    <circle cx="60" cy="60" r="55" fill="none" stroke="#123f6d" stroke-width="4"/>
                    <path d="M 35 60 Q 60 35, 85 60 Q 60 85, 35 60" fill="#123f6d"/>
                    <path d="M 25 60 Q 35 50, 45 60 Q 55 70, 65 60 Q 75 50, 85 60 Q 95 70, 105 60" 
                          stroke="#00d4ff" stroke-width="3" fill="none" stroke-linecap="round"/>
                </svg>
                <span>Customer Feedbacks Tracker</span>
            </a>
            <div class="nav-tabs">
                <a href="/dashboard" class="nav-tab">
                    <span class="nav-tab-icon">üìä</span>
                    <span>Dashboard Analytics</span>
                </a>
                <a href="/improvements" class="nav-tab">
                    <span class="nav-tab-icon">üí°</span>
                    <span>Improvements Opportunities</span>
                </a>
                <a href="/scraping" class="nav-tab active">
                    <span class="nav-tab-icon">üì•</span>
                    <span>Feedbacks Collection</span>
                </a>
                <a href="/logs" class="nav-tab">
                    <span class="nav-tab-icon">üìã</span>
                    <span>Scraping Logs</span>
                </a>
                <a href="/settings" class="nav-tab">
                    <span class="nav-tab-icon">‚öôÔ∏è</span>
                    <span>Settings</span>
                </a>
                <a href="#" class="nav-tab" onclick="event.preventDefault(); toggleHelpMenu(); return false;">
                    <span class="nav-tab-icon">‚ùì</span>
                    <span>Help</span>
                </a>
            </div>
        </div>
        <div class="nav-menu-right">
            <span class="beta-badge" title="Application en version beta">BETA</span>
            <span class="version-badge" id="versionBadge" title="Application version">v1.0.1</span>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Mode">üåì</button>
        </div>
    </nav>
    
    <div class="container">
        <header>
        </header>

        <!-- 1. Keywords manager: Configure what to search for -->
        <div class="controls" style="margin-bottom:20px; gap:8px; align-items:center; background: var(--bg-card); padding: 15px; border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 2px 8px var(--shadow);">
            <h3 style="color: var(--accent-primary); margin: 0 0 10px 0; font-size: 1.1em;">üîë Configure Keywords to Search</h3>
            <input type="text" id="keywordInput" placeholder="Add keyword (e.g., 'ovh vps', 'ovh hosting', 'ovh support')" style="min-width:220px; max-width:400px;">
            <button onclick="addKeyword()">Ôºã Add Keyword</button>
            <button onclick="clearKeywords()" style="background:#ef4444;">Clear All</button>
            <button id="revertKeywordsBtn" onclick="revertKeywords()" style="background:#6b7280; display:none;" title="Restore previously cleared keywords">‚Ü∂ Revert</button>
            <p style="color: var(--text-secondary); font-size: 0.9em; margin-top: 10px; max-width: 700px;">
                üí° <strong>How it works:</strong> Add keywords related to OVH products (e.g., "ovh vps", "ovh hosting", "ovh billing", "ovh support") and click "üÜï Scrape New Data" to collect customer feedback from all sources.
            </p>
            <div id="keywordsList" style="width:100%; margin-top:10px; display:flex; gap:6px; flex-wrap:wrap; justify-content:center;"></div>
            <div id="keywordsSyncIndicator" style="display:none; margin-left:8px; color:#00d4ff; font-size:0.95em; align-items:center;">
                <span class="spinner" aria-hidden="true"></span>
                <span style="margin-left:8px; vertical-align:middle;">Syncing‚Ä¶</span>
            </div>
        </div>


        <!-- 3. Primary action + Scraping buttons -->
        <div class="controls" style="margin-bottom: 30px; background: var(--bg-card); padding: 20px; border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 2px 8px var(--shadow);">
            <h3 style="color: var(--accent-primary); margin: 0 0 15px 0; font-size: 1.2em;">üöÄ Launch Scraping</h3>
            <!-- PRIMARY ACTION - Left side -->
            <button id="btnScrapeAll" onclick="scrapeAllSources()" style="background: linear-gradient(135deg, #00d4ff, #0099ff); font-weight: bold; font-size: 1.05em; padding: 12px 24px;" title="Lance tous les scrapers pour ajouter de nouveaux posts √† la base de donn√©es">
                <span class="btn-text">üÜï Scrape New Data</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <a href="/logs" style="padding: 12px 24px; background: var(--bg-secondary); border: 2px solid var(--accent-primary); border-radius: 8px; color: var(--accent-primary); text-decoration: none; font-weight: bold; font-size: 1.05em; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s ease; margin-left: 10px;" onmouseover="this.style.background='var(--accent-primary)'; this.style.color='var(--bg-primary)';" onmouseout="this.style.background='var(--bg-secondary)'; this.style.color='var(--accent-primary)';" title="Voir les logs de scraping persistants">
                üìã View Logs
            </a>
            <button id="cancelBtn" onclick="cancelRequest()" style="display:none; background:#ef4444;">‚ùå Cancel</button>
            
            <!-- INDIVIDUAL SOURCE SCRAPERS -->
            <button id="btnScrapeX" onclick="scrapeX()">
                <span class="btn-text">üê¶ X/Twitter</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeStackOverflow" onclick="scrapeStackOverflow()">
                <span class="btn-text">üìö StackOverflow</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeNews" onclick="scrapeNews()">
                <span class="btn-text">üì∞ News</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeReddit" onclick="scrapeReddit()">
                <span class="btn-text">üî¥ Reddit</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeTrustpilot" onclick="scrapeTrustpilot()">
                <span class="btn-text">‚≠ê Trustpilot</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeGithub" onclick="scrapeGithub()">
                <span class="btn-text">üíª GitHub</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeOvhForum" onclick="scrapeOvhForum()">
                <span class="btn-text">üí¨ OVH Forum</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeMastodon" onclick="scrapeMastodon()">
                <span class="btn-text">üêò Mastodon</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeG2" onclick="scrapeG2Crowd()">
                <span class="btn-text">‚≠ê G2 Crowd</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            <button id="btnScrapeLinkedIn" onclick="scrapeLinkedIn()">
                <span class="btn-text">üíº LinkedIn</span>
                <span class="btn-spinner" style="display:none;"></span>
            </button>
            
            <!-- UTILITY BUTTONS -->
            <button onclick="cleanupDuplicates()" style="background:#f59e0b;" title="Remove duplicate posts (same URL or same content+author+source)">üîÑ Remove Duplicates</button>
            <button onclick="cleanupNonOvhPosts()" style="background:#ff6b6b;" title="Remove all posts that don't mention OVH or its brands">üóëÔ∏è Remove Non-OVH Posts</button>
        </div>

        <!-- 4. Stats -->
        <!-- Global Stats (all posts in DB) -->
        <div class="stats" style="margin-bottom: 30px; background: var(--bg-card); padding: 20px; border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 2px 8px var(--shadow);">
            <h3 style="color: var(--accent-primary); margin: 0 0 20px 0; font-size: 1.2em; text-align: center;">
                üìä DATABASE STATS (Global)
                <span onclick="openStatsInfoModal()" style="cursor: pointer; background: rgba(0, 212, 255, 0.2); padding: 4px 8px; border-radius: 50%; font-size: 0.9em; transition: all 0.3s ease; display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; margin-left: 8px;" onmouseover="this.style.background='rgba(0, 212, 255, 0.4)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.2)'; this.style.transform='scale(1)'" title="Cliquez pour plus d'informations">‚ÑπÔ∏è</span>
            </h3>
            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <div class="stat-card" style="cursor: default;" title="Total posts dans la base de donn√©es">
                    <strong id="globalTotalPosts">0</strong>
                    <small>Total Posts</small>
                </div>
                <div class="stat-card" style="cursor: default;" title="Posts positifs dans la base">
                    <strong id="globalPositivePosts">0</strong>
                    <small>Positive</small>
                </div>
                <div class="stat-card" style="cursor: default;" title="Posts n√©gatifs dans la base">
                    <strong id="globalNegativePosts">0</strong>
                    <small>Negative</small>
                </div>
                <div class="stat-card" style="cursor: default;" title="Posts neutres dans la base">
                    <strong id="globalNeutralPosts">0</strong>
                    <small>Neutral</small>
                </div>
            </div>
        </div>

        <!-- Filtered Stats (current view) -->
        <div class="stats" style="margin-bottom: 30px; background: var(--bg-card); padding: 20px; border-radius: 12px; border: 1px solid var(--border-color); box-shadow: 0 2px 8px var(--shadow);">
            <h3 style="color: var(--accent-primary); margin: 0 0 20px 0; font-size: 1.2em; text-align: center;">üìà FILTERED STATS (Current View)</h3>
            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <div class="stat-card" onclick="filterBySentiment('', event)" title="Posts affich√©s apr√®s filtrage">
                    <strong id="totalPosts">0</strong>
                    <small>Total</small>
                </div>
                <div class="stat-card" onclick="filterBySentiment('positive', event)" title="Posts positifs affich√©s">
                    <strong id="positivePosts">0</strong>
                    <small>Positive</small>
                </div>
                <div class="stat-card" onclick="filterBySentiment('negative', event)" title="Posts n√©gatifs affich√©s (complaints)">
                    <strong id="negativePosts">0</strong>
                    <small>Negative</small>
                </div>
                <div class="stat-card" onclick="filterBySentiment('neutral', event)" title="Posts neutres affich√©s">
                    <strong id="neutralPosts">0</strong>
                    <small>Neutral</small>
                </div>
            </div>
        </div>

        <!-- 5. Filters & Search -->
        <div class="controls" style="margin-bottom: 20px; margin-top: 30px; border-top: 2px solid rgba(0, 212, 255, 0.3); padding-top: 20px;">
            <h3 style="color: var(--accent-primary); margin: 0 0 15px 0; font-size: 1.1em;">üîç Filter & Search Results</h3>
            
            <input type="text" id="searchInput" placeholder="üîç Search by keyword in posts (e.g., 'dns', 'billing', 'down')...">
            
            <select id="sentimentFilter">
                <option value="">All Sentiments</option>
                <option value="positive">‚úÖ Positive</option>
                <option value="negative">‚ùå Negative</option>
                <option value="neutral">‚ûñ Neutral</option>
            </select>
            
            <select id="sourceFilter">
                <option value="">All Sources</option>
                <option value="X/Twitter">üê¶ Twitter/X</option>
                <option value="Stack Overflow">üìö Stack Overflow</option>
                <option value="GitHub Issues">üíª GitHub Issues</option>
                <option value="GitHub Discussions">üí¨ GitHub Discussions</option>
                <option value="Reddit">üî¥ Reddit</option>
                <option value="Google News">üì∞ Google News</option>
                <option value="Trustpilot">‚≠ê Trustpilot</option>
            </select>
            
            <select id="languageFilter">
                <option value="">All Languages</option>
                <option value="fr">üá´üá∑ Fran√ßais</option>
                <option value="en">üá¨üáß English</option>
                <option value="other">üåç Other</option>
            </select>
            
            <select id="ovhProductFilter" title="Filter by OVH Product">
                <option value="">All OVH Products</option>
                <optgroup label="üåê Web & Hosting">
                    <option value="web-hosting">Web Hosting</option>
                    <option value="wordpress">WordPress Hosting</option>
                    <option value="email">Email / Exchange</option>
                    <option value="domain">Domain Names</option>
                </optgroup>
                <optgroup label="‚òÅÔ∏è Cloud & Servers">
                    <option value="vps">VPS (Virtual Private Server)</option>
                    <option value="dedicated">Dedicated Servers</option>
                    <option value="public-cloud">Public Cloud</option>
                    <option value="private-cloud">Private Cloud</option>
                    <option value="hosted-private-cloud">Hosted Private Cloud</option>
                </optgroup>
                <optgroup label="üíæ Storage & Backup">
                    <option value="object-storage">Object Storage</option>
                    <option value="cloud-archive">Cloud Archive</option>
                    <option value="nas-ha">NAS-HA</option>
                    <option value="veeam">Veeam Backup</option>
                </optgroup>
                <optgroup label="üåç Network & CDN">
                    <option value="cdn">CDN</option>
                    <option value="load-balancer">Load Balancer</option>
                    <option value="ddos">DDoS Protection</option>
                    <option value="vrack">vRack</option>
                </optgroup>
                <optgroup label="üì± Telecom">
                    <option value="voip">VoIP / Telephony</option>
                    <option value="sms">SMS</option>
                    <option value="fax">Fax</option>
                </optgroup>
                <optgroup label="üîß Support & Billing">
                    <option value="support">Customer Support</option>
                    <option value="billing">Billing Issues</option>
                    <option value="manager">OVH Manager</option>
                    <option value="api">OVH API</option>
                </optgroup>
            </select>
            
            <input type="date" id="dateFrom" title="From Date" placeholder="From">
            <input type="date" id="dateTo" title="To Date" placeholder="To">
            
            <button onclick="applyFilters()" class="apply-btn" style="background: linear-gradient(135deg, #00d4ff, #0099ff); font-weight: bold; padding: 12px 24px;">‚úì Apply Filters</button>
            <button onclick="clearAllFilters()" style="background:#ef4444; margin-left:10px;">üóëÔ∏è Clear Filters</button>
            <span id="activeFiltersCount" class="filter-count" style="display:none;">0</span>
        </div>

        <!-- Sort Controls -->
        <div class="sort-controls" style="margin-bottom: 20px;">
            <label>Sort by:</label>
            <select id="sortBy" onchange="applySorting()">
                <option value="date-desc">üìÖ Date (Newest)</option>
                <option value="date-asc">üìÖ Date (Oldest)</option>
                <option value="sentiment-desc">üò° Sentiment (Negative First)</option>
                <option value="sentiment-asc">üòä Sentiment (Positive First)</option>
                <option value="source-asc">üìä Source (A-Z)</option>
                <option value="source-desc">üìä Source (Z-A)</option>
            </select>
        </div>

        <!-- 6. Posts Gallery -->
        <div id="gallery" class="gallery"></div>

        <!-- Statistics, Backlog & Export Buttons -->
        <div style="margin-bottom: 30px; text-align: center; display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
            <button onclick="openChartModal()" style="padding: 18px 40px; background: linear-gradient(135deg, #00d4ff, #0099ff); border: none; border-radius: 12px; color: #1a1a2e; font-weight: bold; font-size: 1.2em; cursor: pointer; box-shadow: 0 8px 20px rgba(0, 212, 255, 0.4); transition: all 0.3s ease; position: relative; overflow: hidden;" onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 12px 30px rgba(0, 212, 255, 0.6)'" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 20px rgba(0, 212, 255, 0.4)'">
                üìä Statistics
            </button>
            <button onclick="toggleBacklog()" style="padding: 18px 40px; background: linear-gradient(135deg, #34d399, #10b981); border: none; border-radius: 12px; color: #1a1a2e; font-weight: bold; font-size: 1.2em; cursor: pointer; box-shadow: 0 8px 20px rgba(52, 211, 153, 0.4); transition: all 0.3s ease; position: relative; overflow: hidden;" onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 12px 30px rgba(52, 211, 153, 0.6)'" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 20px rgba(52, 211, 153, 0.4)'">
                üìã Backlog
            </button>
            <button onclick="exportFilteredResults()" style="padding: 18px 40px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 12px; color: #fff; font-weight: bold; font-size: 1.2em; cursor: pointer; box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4); transition: all 0.3s ease; position: relative; overflow: hidden;" onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 12px 30px rgba(16, 185, 129, 0.6)'" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 20px rgba(16, 185, 129, 0.4)'">
                üì• Export Posts
            </button>
        </div>

        <!-- Chart Modal -->
        <div id="chartModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; overflow-y: auto;">
            <div class="modal-content chart-modal-bg" style="max-width: 90%; margin: 50px auto; border-radius: 15px; padding: 30px; box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3); position: relative;">
                <button onclick="closeChartModal()" style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; border-radius: 50%; width: 40px; height: 40px; color: var(--text-primary); font-size: 1.5em; cursor: pointer; font-weight: bold; line-height: 1;">√ó</button>
                
                <h2 style="color: var(--accent-primary); margin-bottom: 25px; text-align: center; font-size: 1.8em;">üìä Statistics</h2>
                
                <!-- Date Range Controls -->
                <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; padding: 15px; background: rgba(0, 212, 255, 0.05); border-radius: 8px; border: 1px solid rgba(0, 212, 255, 0.2);">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="color: var(--text-secondary); font-size: 0.95em;">üìÖ From:</label>
                        <input type="date" id="chartDateFrom" onchange="syncDateFiltersFromChart()" style="padding: 8px 12px; border: none; border-radius: 6px; background: var(--input-bg); color: var(--text-primary); cursor: pointer;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="color: var(--text-secondary); font-size: 0.95em;">üìÖ To:</label>
                        <input type="date" id="chartDateTo" onchange="syncDateFiltersFromChart()" style="padding: 8px 12px; border: none; border-radius: 6px; background: var(--input-bg); color: var(--text-primary); cursor: pointer;">
                    </div>
                    <button onclick="applyChartDateFilter()" style="padding: 8px 20px; border: none; border-radius: 8px; background: var(--accent-primary); color: #1a1a2e; cursor: pointer; font-size: 1em; font-weight: bold;">‚úì Apply Timeline</button>
                    <button onclick="clearChartDates()" style="padding: 8px 20px; border: none; border-radius: 8px; background: #ef4444; color: var(--text-primary); cursor: pointer; font-size: 1em;">üóëÔ∏è Clear</button>
                </div>
                
                <!-- Chart Controls -->
                <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 25px; flex-wrap: wrap;">
                    <select id="chartSentimentFilter" onchange="updateChart()" style="padding: 10px 15px; border: none; border-radius: 8px; background: var(--input-bg); color: var(--text-primary); cursor: pointer; font-size: 1em;">
                        <option value="all">All Sentiments</option>
                        <option value="positive">Positive Only</option>
                        <option value="negative">Negative Only</option>
                        <option value="neutral">Neutral Only</option>
                    </select>
                    <select id="chartProductFilter" onchange="updateChart()" style="padding: 10px 15px; border: none; border-radius: 8px; background: var(--input-bg); color: var(--text-primary); cursor: pointer; font-size: 1em;">
                        <option value="all">All Products</option>
                        <!-- Options will be populated dynamically -->
                    </select>
                    <select id="chartGrouping" onchange="updateChart()" style="padding: 10px 15px; border: none; border-radius: 8px; background: var(--input-bg); color: var(--text-primary); cursor: pointer; font-size: 1em;">
                        <option value="day">By Day</option>
                        <option value="week">By Week</option>
                        <option value="month">By Month</option>
                    </select>
                    <button onclick="toggleChartView()" style="padding: 10px 15px; border: none; border-radius: 8px; background: var(--input-bg); color: var(--text-primary); cursor: pointer; font-size: 1em;">üìä Toggle View (Bar/Line)</button>
                    <button onclick="refreshChartData()" style="padding: 10px 15px; border: none; border-radius: 8px; background: #34d399; color: #1a1a2e; cursor: pointer; font-size: 1em; font-weight: bold;" title="Reload data from database">üì• Reload from DB</button>
                </div>
                
                <!-- Charts Container -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-bottom: 25px;">
                    <!-- Timeline Chart -->
                    <div>
                        <h3 style="color: var(--accent-primary); margin-bottom: 15px; text-align: center;">üìà Timeline & Histogram</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85em; text-align: center; margin-bottom: 10px; font-style: italic;">
                            Click on a bar to filter posts by that time period
                        </p>
                        <canvas id="timelineChart" style="max-height: 400px; width: 100%; cursor: pointer;"></canvas>
                    </div>
                    <!-- Product Distribution Pie Chart -->
                    <div>
                        <h3 style="color: var(--accent-primary); margin-bottom: 10px; text-align: center;">ü•ß Distribution per Product</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85em; text-align: center; margin-bottom: 15px; font-style: italic;">
                            Click on a slice to filter posts by that product
                        </p>
                        <canvas id="productPieChart" style="max-height: 400px; width: 100%; cursor: pointer;"></canvas>
                    </div>
                </div>
                
                <div style="margin-top: 25px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border: 1px solid rgba(0, 212, 255, 0.3);">
                    <p style="color: var(--text-secondary); margin: 0; text-align: center;">
                        üí° <strong>Tip:</strong> The charts respect all your date, sentiment, and product filters. Use "üÜï Scrape New Data" button to collect new posts from all sources.
                    </p>
                </div>
            </div>
        </div>

        <!-- Stats Info Modal -->
        <div id="statsInfoModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10001; overflow-y: auto;">
            <div class="modal-content" style="max-width: 700px; margin: 50px auto; border-radius: 15px; padding: 30px; box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3); position: relative;">
                <button onclick="closeStatsInfoModal()" style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; border-radius: 50%; width: 40px; height: 40px; color: var(--text-primary); font-size: 1.5em; cursor: pointer; font-weight: bold; line-height: 1;">√ó</button>
                
                <h2 style="color: var(--accent-primary); margin-bottom: 25px; text-align: center; font-size: 1.8em;">üìä Where do the statistics come from?</h2>
                
                <div style="color: var(--text-secondary); line-height: 1.8;">
                    <div style="margin-bottom: 25px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-left: 4px solid #00d4ff; border-radius: 8px;">
                        <h3 style="color: var(--accent-primary); margin: 0 0 10px 0; font-size: 1.2em;">üóÑÔ∏è SQLite Database</h3>
                        <p style="margin: 0;">All statistics come from the SQLite database <code style="background: rgba(0, 0, 0, 0.3); padding: 2px 6px; border-radius: 4px; color: #34d399;">complaints.db</code> located in the backend folder.</p>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #34d399; margin: 0 0 15px 0; font-size: 1.1em;">üì• Data Sources:</h3>
                        <ul style="list-style: none; padding: 0; margin: 0;">
                            <li style="padding: 10px; margin-bottom: 8px; background: var(--bg-card); border-radius: 6px; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 10px;">üê¶</span>
                                <div>
                                    <strong style="color: var(--text-primary);">X/Twitter</strong><br>
                                    <small style="color: var(--text-secondary);">Posts and tweets via Nitter (open-source alternative)</small>
                                </div>
                            </li>
                            <li style="padding: 10px; margin-bottom: 8px; background: var(--bg-card); border-radius: 6px; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 10px;">üìö</span>
                                <div>
                                    <strong style="color: var(--text-primary);">StackOverflow</strong><br>
                                    <small style="color: var(--text-secondary);">Technical questions and answers</small>
                                </div>
                            </li>
                            <li style="padding: 10px; margin-bottom: 8px; background: var(--bg-card); border-radius: 6px; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 10px;">üì∞</span>
                                <div>
                                    <strong style="color: var(--text-primary);">Google News</strong><br>
                                    <small style="color: var(--text-secondary);">Press articles and news</small>
                                </div>
                            </li>
                            <li style="padding: 10px; margin-bottom: 8px; background: var(--bg-card); border-radius: 6px; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 10px;">üî¥</span>
                                <div>
                                    <strong style="color: var(--text-primary);">Reddit</strong><br>
                                    <small style="color: var(--text-secondary);">Community discussions and feedback</small>
                                </div>
                            </li>
                            <li style="padding: 10px; margin-bottom: 8px; background: var(--bg-card); border-radius: 6px; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 10px;">‚≠ê</span>
                                <div>
                                    <strong style="color: var(--text-primary);">Trustpilot</strong><br>
                                    <small style="color: var(--text-secondary);">Customer reviews and ratings</small>
                                </div>
                            </li>
                        </ul>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #f59e0b; margin: 0 0 15px 0; font-size: 1.1em;">ü§ñ Automatic Analysis:</h3>
                        <ul style="padding-left: 20px; margin: 0;">
                            <li style="margin-bottom: 8px;"><strong>Sentiment Analysis (VADER)</strong>: Each post is automatically analyzed to determine if it's positive, negative, or neutral.</li>
                            <li style="margin-bottom: 8px;"><strong>Language Detection</strong>: The language of each post is automatically detected (FR, EN, etc.).</li>
                            <li style="margin-bottom: 8px;"><strong>Deduplication</strong>: Duplicate posts (same URL) are not added multiple times.</li>
                            <li style="margin-bottom: 8px;"><strong>Automatic Filtering</strong>: Sample/fake posts are automatically excluded.</li>
                        </ul>
                    </div>
                    
                    <div style="padding: 15px; background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; border-radius: 8px;">
                        <h3 style="color: #ef4444; margin: 0 0 10px 0; font-size: 1.1em;">‚öôÔ∏è Updates:</h3>
                        <p style="margin: 0; color: var(--text-secondary);">
                            ‚Ä¢ <strong style="color: var(--text-primary);">Manual</strong>: Click "üÜï Scrape New Data" to launch all scrapers<br>
                            ‚Ä¢ <strong style="color: var(--text-primary);">Automatic</strong>: The server automatically scrapes every 3 hours<br>
                            ‚Ä¢ <strong style="color: var(--text-primary);">By source</strong>: Use individual buttons (üê¶ X, üìö SO, etc.)
                        </p>
                    </div>
                    
                    <div style="margin-top: 25px; text-align: center; padding: 15px; background: rgba(52, 211, 153, 0.1); border-radius: 8px; border: 1px solid rgba(52, 211, 153, 0.3);">
                        <p style="margin: 0; color: #34d399;">
                            ‚úÖ <strong>All data is persistent</strong>: It's saved in the SQLite database and doesn't disappear on restart.
                        </p>
                    </div>
                    
                    <div style="margin-top: 15px; text-align: center; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border: 1px solid rgba(0, 212, 255, 0.3);">
                        <p style="margin: 0; color: var(--accent-primary);">
                            üßπ <strong>Automatic Cleanup</strong>: On server startup, posts that don't mention OVH (or its brands: Kimsufi, SoYouStart) are automatically deleted.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Post Preview Modal -->
        <div id="postPreviewModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10002; overflow-y: auto;">
            <div class="modal-content" style="max-width: 800px; margin: 50px auto; border-radius: 15px; padding: 30px; box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3); position: relative;">
                <button onclick="closePostPreviewModal()" style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; border-radius: 50%; width: 40px; height: 40px; color: var(--text-primary); font-size: 1.5em; cursor: pointer; font-weight: bold; line-height: 1;">√ó</button>
                
                <h2 style="color: var(--accent-primary); margin-bottom: 25px; text-align: center; font-size: 1.8em;">üëÅÔ∏è Post Preview</h2>
                
                <div id="postPreviewContent" style="color: var(--text-primary); line-height: 1.8;">
                    <!-- Content will be populated dynamically -->
                </div>
                
                <div style="margin-top: 25px; text-align: center;">
                    <a id="postPreviewLink" href="#" target="_blank" style="padding: 10px 20px; background: var(--accent-primary); color: #1a1a2e; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">üîó Open Original Post</a>
                </div>
            </div>
        </div>


        <!-- Backlog Sidebar -->
        <div id="backlogSidebar" style="position: fixed; top: 0; right: -450px; width: 450px; height: 100vh; background: var(--bg-card); box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3); z-index: 9999; transition: right 0.3s ease; overflow-y: auto; border-left: 2px solid var(--accent-primary);">
            <div style="padding: 20px; border-bottom: 2px solid var(--border-color); background: var(--bg-card-hover); position: sticky; top: 0; z-index: 10;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="margin: 0; color: var(--text-primary); font-size: 1.5em;">üìã Backlog</h2>
                    <button onclick="toggleBacklog()" style="background: #ef4444; border: none; border-radius: 50%; width: 35px; height: 35px; color: #fff; cursor: pointer; font-size: 1.2em; font-weight: bold; line-height: 1;">√ó</button>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <button onclick="toggleBacklogView()" id="backlogViewToggle" style="padding: 8px 15px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); cursor: pointer; font-size: 0.9em;" title="Toggle between card and list view">üìã Card View</button>
                    <button onclick="clearBacklog()" style="padding: 8px 15px; background: #ef4444; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-size: 0.9em;">üóëÔ∏è Clear</button>
                    <button onclick="exportBacklog()" style="padding: 8px 15px; background: #10b981; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-size: 0.9em;">üì• Export CSV</button>
                    <button onclick="generateImprovementIdeas()" style="padding: 8px 15px; background: var(--accent-primary); border: none; border-radius: 6px; color: #1a1a2e; cursor: pointer; font-size: 0.9em; font-weight: bold;">üí° Generate Ideas</button>
                </div>
            </div>
            <div id="backlogGallery" style="padding: 20px;">
                <!-- Backlog posts will be rendered here -->
            </div>
        </div>
        
        <!-- Backdrop for sidebar -->
        <div id="backlogBackdrop" onclick="toggleBacklog()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 9998; transition: opacity 0.3s ease;"></div>

        <!-- Improvement Ideas Modal -->
        <div id="ideasModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10003; overflow-y: auto;">
            <div class="modal-content" style="max-width: 900px; margin: 50px auto; border-radius: 15px; padding: 30px; box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3); position: relative;">
                <button onclick="closeIdeasModal()" style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; border-radius: 50%; width: 40px; height: 40px; color: var(--text-primary); font-size: 1.5em; cursor: pointer; font-weight: bold; line-height: 1;">√ó</button>
                
                <h2 style="color: var(--accent-primary); margin-bottom: 25px; text-align: center; font-size: 1.8em;">üí° Product Improvement Ideas</h2>
                
                <div id="ideasContent" style="color: var(--text-primary);">
                    <!-- Ideas will be populated here -->
                </div>
                
                <div style="margin-top: 25px; text-align: center;">
                    <button onclick="closeIdeasModal()" style="padding: 10px 20px; background: #6b7280; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-size: 1em; margin-right: 10px;">Close</button>
                </div>
            </div>
        </div>

        <!-- Help Menu -->
        <div class="help-menu" id="helpMenu">
            <div class="help-menu-header">
                <h2>üìñ Help & Information</h2>
                <button class="help-menu-close" onclick="toggleHelpMenu()">√ó</button>
            </div>
            <div class="help-menu-content">
                <h3>üí¨ Customer Feedbacks Tracker</h3>
                <p>
                    <strong>Customer Feedbacks Tracker</strong> is a comprehensive monitoring and analytics tool that collects, stores, and analyzes customer feedback about OVH products and services from multiple online sources.
                </p>

                <h3>üìã Page Overview</h3>
                <p>
                    You are currently on the <strong>Feedbacks Collection</strong> page. This application has three main sections:
                </p>
                <ul>
                    <li><strong>üì• Feedbacks Collection:</strong> Configure keywords, launch scrapers, and manage your data</li>
                    <li><strong>üìä Dashboard Analytics:</strong> Visual analytics with charts, trends, and real-time insights</li>
                    <li><strong>üí° Improvements Opportunities:</strong> Identify pain points and prioritize improvement actions</li>
                </ul>

                <h3>üöÄ Quick Start Guide</h3>
                <ol>
                    <li><strong>Configure Keywords:</strong> Add keywords related to OVH products (e.g., "ovh vps", "ovh hosting", "ovh billing")</li>
                    <li><strong>Launch Scraping:</strong> Click "üÜï Scrape New Data" to collect feedback from all sources, or use individual scraper buttons</li>
                    <li><strong>View Results:</strong> Navigate to "Dashboard Analytics" or "Improvements Opportunities" to analyze the collected data</li>
                </ol>

                <h3>üîë Keywords Configuration</h3>
                <p>
                    Add keywords to search for across all sources. Examples:
                </p>
                <ul>
                    <li><code>"ovh vps"</code> - VPS-related feedback</li>
                    <li><code>"ovh hosting"</code> - Web hosting feedback</li>
                    <li><code>"ovh billing"</code> - Billing and payment issues</li>
                    <li><code>"ovh support"</code> - Customer support feedback</li>
                </ul>
                <p style="margin-top: 10px;">
                    <strong>üí° Tip:</strong> Use specific product names for better results. Keywords are saved automatically.
                </p>

                <h3>‚öôÔ∏è Settings</h3>
                <p>
                    Configure your API keys and settings in the Settings page:
                </p>
                <ul>
                    <li><strong>OpenAI API Key:</strong> Get it from <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--accent-primary);">platform.openai.com</a></li>
                    <li><strong>Anthropic API Key:</strong> Get it from <a href="https://console.anthropic.com/" target="_blank" style="color: var(--accent-primary);">console.anthropic.com</a></li>
                    <li><strong>Provider Selection:</strong> Choose between OpenAI (GPT-4o-mini) or Anthropic (Claude 3 Haiku)</li>
                </ul>
                <p style="margin-top: 10px;">
                    <strong>Features:</strong> API key configuration for OpenAI, Anthropic, Google, GitHub, and Trustpilot.
                </p>

                <h3>üîÑ Scraping Operations</h3>
                <ul>
                    <li><strong>üÜï Scrape New Data:</strong> Launches all scrapers simultaneously for all configured keywords</li>
                    <li><strong>Individual Scrapers:</strong> Use specific scraper buttons (X/Twitter, Reddit, Trustpilot, etc.) for targeted collection</li>
                    <li><strong>Progress Tracking:</strong> Monitor scraping progress in real-time with job status updates</li>
                    <li><strong>Cancel Operation:</strong> Stop long-running scraping jobs if needed</li>
                </ul>

                <h3>üîç Filtering & Search</h3>
                <ul>
                    <li><strong>Text Search:</strong> Search for keywords within post content</li>
                    <li><strong>Sentiment Filter:</strong> Filter by positive, negative, or neutral sentiment</li>
                    <li><strong>Source Filter:</strong> Filter by data source (X, Reddit, Trustpilot, etc.)</li>
                    <li><strong>Language Filter:</strong> Filter by language (French, English, Other)</li>
                    <li><strong>Product Filter:</strong> Filter by OVH product category (VPS, Hosting, Billing, etc.)</li>
                    <li><strong>Date Range:</strong> Filter posts by creation date</li>
                </ul>

                <h3>üìä Statistics</h3>
                <ul>
                    <li><strong>Database Stats:</strong> Global statistics for all posts in the database</li>
                    <li><strong>Filtered Stats:</strong> Statistics for posts matching current filters</li>
                    <li><strong>Click to Filter:</strong> Click on stat cards to filter by sentiment</li>
                </ul>

                <h3>üìã Backlog & Export</h3>
                <ul>
                    <li><strong>Add to Backlog:</strong> Save important posts for later review</li>
                    <li><strong>Export CSV:</strong> Export backlog or filtered posts to CSV file</li>
                    <li><strong>Generate Ideas:</strong> Use AI to generate improvement ideas from backlog posts</li>
                </ul>

                <h3>üåê Data Sources</h3>
                <ul>
                    <li><strong>üê¶ X (Twitter)</strong> - Real-time customer complaints and feedback</li>
                    <li><strong>üìö Stack Overflow</strong> - Technical support questions</li>
                    <li><strong>üì∞ Google News</strong> - News articles and press releases</li>
                    <li><strong>üî¥ Reddit</strong> - Community discussions and feedback</li>
                    <li><strong>‚≠ê Trustpilot</strong> - Customer reviews and ratings</li>
                    <li><strong>üíª GitHub</strong> - Issues and discussions</li>
                    <li><strong>üí¨ OVH Forum</strong> - Official forum discussions</li>
                    <li><strong>üêò Mastodon</strong> - Decentralized social media</li>
                    <li><strong>‚≠ê G2 Crowd</strong> - Software reviews</li>
                </ul>

                <h3>üé® Navigation</h3>
                <ul>
                    <li><strong>üì• Feedbacks Collection:</strong> Current page - manage data collection and configuration</li>
                    <li><strong>üìä Dashboard Analytics:</strong> Visual analytics with charts and insights</li>
                    <li><strong>üí° Improvements Opportunities:</strong> Pain points analysis and improvement prioritization</li>
                    <li><strong>‚ùì Help:</strong> This menu - access help and documentation</li>
                    <li><strong>üåì Theme Toggle:</strong> Switch between light and dark mode</li>
                </ul>

                <div style="margin-top: 25px; padding: 15px; background: rgba(255, 165, 0, 0.1); border-left: 4px solid #ff9800; border-radius: 8px;">
                    <h3 style="color: #ff9800; margin: 0 0 10px 0;">üí° Pro Tips</h3>
                    <ul style="margin: 0; padding-left: 20px;">
                        <li>Run scraping daily to build a comprehensive feedback history</li>
                        <li>Use the backlog feature to track critical issues</li>
                        <li>Configure API keys in Settings to unlock AI-powered insights</li>
                        <li>Filter by product to focus on specific areas</li>
                        <li>Export data to CSV for external analysis</li>
                    </ul>
                </div>
            </div>
        </div>

        <div id="infoPanel" class="modal-overlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; z-index:1000; overflow-y:auto;">
            <div class="modal-content" style="max-width:900px; margin:30px auto; padding:30px; border-radius:12px; border:1px solid rgba(0,212,255,0.3);">
                <button onclick="toggleInfo()" style="float:right; padding:8px 15px; background:#ef4444; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:bold;">‚úï Close</button>
                
                <h1 style="color:var(--accent-primary); margin-bottom:20px;">üí¨ Customer Feedbacks Tracker</h1>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üìñ What does it do?</h2>
                <p style="line-height:1.6; color:var(--text-secondary);">
                    <strong>Customer Feedbacks Tracker</strong> is a monitoring tool that <strong>collects and accumulates customer feedback</strong> about <strong>all OVH products and services</strong> from multiple sources. 
                    The data is <strong>stored permanently</strong> in a SQLite database and analyzed automatically for sentiment (positive, negative, neutral).
                </p>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üöÄ How to use it?</h2>
                <ol style="color:var(--text-secondary); line-height:2; margin-left:20px;">
                    <li><strong>Step 1:</strong> Configure keywords for products you want to monitor (e.g., "ovh vps", "ovh hosting", "ovh billing")</li>
                    <li><strong>Step 2:</strong> Click "üÜï Scrape New Data" to collect feedback from all sources</li>
                    <li><strong>Step 3:</strong> Customer feedback is automatically saved to the database (no duplicates)</li>
                    <li><strong>Step 4:</strong> Use the <strong>"All OVH Products"</strong> filter to show only posts about specific products (VPS, Hosting, Support, etc.)</li>
                    <li><strong>Step 5:</strong> View timeline charts to analyze trends and sentiment over time</li>
                </ol>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üéØ Filter by Product</h2>
                <p style="line-height:1.6; color:var(--text-secondary);">
                    After scraping, use the <strong>"All OVH Products"</strong> dropdown to filter feedback by product category:
                </p>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><strong>üåê Web & Hosting:</strong> Web Hosting, WordPress, Email, Domains</li>
                    <li><strong>‚òÅÔ∏è Cloud & Servers:</strong> VPS, Dedicated Servers, Public Cloud, Private Cloud</li>
                    <li><strong>üíæ Storage & Backup:</strong> Object Storage, NAS, Veeam Backup</li>
                    <li><strong>üåç Network & CDN:</strong> CDN, Load Balancer, DDoS Protection</li>
                    <li><strong>üì± Telecom:</strong> VoIP, SMS, Fax</li>
                    <li><strong>üîß Support & Billing:</strong> Customer Support, Billing, OVH Manager, API</li>
                </ul>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üåê Data Sources</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><strong>üê¶ X (Twitter)</strong> - Real-time customer complaints and feedback</li>
                    <li><strong>üìö Stack Overflow</strong> - Technical support questions</li>
                    <li><strong>üì∞ Google News</strong> - News articles and press releases</li>
                    <li><strong>üî¥ Reddit</strong> - Community discussions and feedback</li>
                    <li><strong>‚≠ê Trustpilot</strong> - Customer reviews and ratings</li>
                    <li><strong>üíª GitHub</strong> - Issues and discussions</li>
                </ul>

                <div style="margin-top: 25px; padding: 15px; background: rgba(255, 165, 0, 0.1); border-left: 4px solid #ff9800; border-radius: 8px;">
                    <h3 style="color: #ff9800; margin: 0 0 10px 0;">‚ö†Ô∏è Why so few results in the past?</h3>
                    <p style="margin: 0; color: var(--text-secondary); line-height: 1.8;">
                        Public APIs (Twitter, StackOverflow, News, etc.) limit access to <strong>recent posts only</strong> (typically last 7-30 days).
                        <br><br>
                        üìå <strong>Solution:</strong> The application <strong>accumulates data over time</strong>. The more you scrape regularly, the more history you'll build!
                        <br><br>
                        üí° <strong>Tip:</strong> Launch "Scrape New Data" daily to build a complete history. Posts are permanently saved in the database.
                    </p>
                </div>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üîë Keywords Configuration</h2>
                <p style="line-height:1.6; color:var(--text-secondary);">
                    Add specific keywords to search for. Examples:
                </p>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px; background:rgba(0,212,255,0.1); padding:15px; border-radius:6px;">
                    <li><code style="background:var(--bg-card); padding:4px 8px; border-radius:4px;">"OVH domain"</code></li>
                    <li><code style="background:var(--bg-card); padding:4px 8px; border-radius:4px;">"OVH complaint"</code></li>
                    <li><code style="background:var(--bg-card); padding:4px 8px; border-radius:4px;">"OVH support"</code></li>
                </ul>
                <p style="line-height:1.6; color:var(--text-secondary); margin-top:15px;">
                    You can also enter custom keywords in the "Scrape" buttons to search for specific terms.
                </p>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">‚öôÔ∏è How It Works</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><strong>Manual Scraping:</strong> Click scraper buttons to fetch customer complaints immediately from each source</li>
                    <li><strong>Trustpilot Focus:</strong> Real customer reviews with ratings and sentiment signals</li>
                    <li><strong>X/Twitter Improvement:</strong> Searches complaint keywords (bad support, expensive, overpriced, confusing interface, etc.)</li>
                    <li><strong>GitHub Integration:</strong> Customer experience issues and service feedback, not technical bugs</li>
                    <li><strong>Auto Scraping:</strong> Every 3 hours, automatically collects all customer feedback</li>
                    <li><strong>Sentiment Analysis:</strong> Each post analyzed for negative/positive/neutral sentiment</li>
                    <li><strong>Database Storage:</strong> All posts stored in SQLite for persistent access and analysis</li>
                    <li><strong>Filtering:</strong> Filter by date range, source, sentiment, and custom keywords</li>
                    <li><strong>Backlog:</strong> Save important complaints to your personal backlog for follow-up</li>
                </ul>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üìä Sentiment Analysis</h2>
                <p style="line-height:1.6; color:var(--text-secondary);">
                    Posts are classified as:
                </p>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><span style="color:#34d399;">‚úì POSITIVE</span> - Satisfactory feedback, positive experiences (score > 0.05)</li>
                    <li><span style="color:#d1d5db;">‚óá NEUTRAL</span> - Factual statements, no clear sentiment (-0.05 to 0.05)</li>
                    <li><span style="color:#ef4444;">‚úó NEGATIVE</span> - Complaints, issues, dissatisfaction (score < -0.05)</li>
                </ul>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üíæ Features</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><strong>Timeline Filter:</strong> Select date ranges to analyze posts over time</li>
                    <li><strong>Source Filter:</strong> Focus on specific platforms (X, Reddit, Google News, etc.)</li>
                    <li><strong>Sentiment Filter:</strong> Show only positive, negative, or neutral posts</li>
                    <li><strong>Text Search:</strong> Search for specific keywords within post content</li>
                    <li><strong>Cancel Button:</strong> Stop long-running scraping operations</li>
                    <li><strong>Backlog & Export:</strong> Save posts and export as CSV for further analysis</li>
                </ul>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">‚ö†Ô∏è Limitations & Disclaimer</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px; background:rgba(239,68,68,0.1); padding:15px; border-radius:6px;">
                    <li><strong>Data Limitations:</strong> Scraping is subject to rate limits and may not capture all posts</li>
                    <li><strong>Sentiment Accuracy:</strong> VADER sentiment analysis is statistical and may have false positives</li>
                    <li><strong>Data Privacy:</strong> This tool monitors publicly available social media data only</li>
                    <li><strong>Legal Notice:</strong> Users are responsible for complying with platform ToS and applicable laws</li>
                    <li><strong>Real-time Accuracy:</strong> There may be delays between post creation and indexing (typically < 1 hour)</li>
                </ul>

                <h2 style="color:#ff6b6b; margin-top:30px; margin-bottom:15px;">üö´ Why Some Platforms Are Not Supported</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px; background:rgba(255,107,107,0.1); padding:15px; border-radius:6px;">
                    <li><strong style="color:#ff8787;">‚ùå Reddit:</strong> Uses aggressive anti-scraping (403 Forbidden). Would require OAuth2 authentication and API credentials. Disabled for simplicity.</li>
                    <li><strong style="color:#ff8787;">‚ùå LinkedIn:</strong> Strictly prohibits automated data extraction in Terms of Service. No public API available for posts. Scraping violates legal terms.</li>
                    <li><strong style="color:#ff8787;">‚ùå Facebook:</strong> No public API for accessing posts. Requires special app review by Meta. Data extraction heavily restricted for privacy/security reasons.</li>
                    <li><strong style="color:#34d399;">‚úÖ Supported Instead:</strong> X/Twitter, GitHub Issues, Stack Overflow, Reddit (RSS), Google News - All have public APIs or RSS feeds accessible without authentication</li>
                </ul>

                <h2 style="color:var(--accent-primary); margin-top:30px; margin-bottom:15px;">üîß Technical Details</h2>
                <ul style="color:var(--text-secondary); line-height:1.8; margin-left:20px;">
                    <li><strong style="color: var(--text-primary);">Backend:</strong> FastAPI (Python) with SQLite database</li>
                    <li><strong>Frontend:</strong> Vanilla JavaScript with localStorage for backlog persistence</li>
                    <li><strong>Sentiment:</strong> VADER SentimentIntensityAnalyzer</li>
                    <li><strong>Scheduler:</strong> APScheduler for automated background jobs</li>
                    <li><strong>API Base:</strong> http://127.0.0.1:8000 (adjust if deployed)</li>
                </ul>

                <p style="margin-top:40px; padding-top:20px; border-top:1px solid rgba(0,212,255,0.2); color:var(--text-muted); font-size:0.9em;">
                    Last updated: January 2026 | For support or issues, check the backend logs
                </p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <!-- Version Switch Modal -->
    <div id="versionModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10004;">
        <div class="modal-content" style="max-width: 500px; margin: auto; border-radius: 15px; padding: 30px; box-shadow: 0 10px 50px rgba(0, 212, 255, 0.3); position: relative; background: var(--modal-bg);">
            <button onclick="closeVersionModal()" style="position: absolute; top: 20px; right: 20px; background: #ef4444; border: none; border-radius: 50%; width: 40px; height: 40px; color: var(--text-primary); font-size: 1.5em; cursor: pointer; font-weight: bold; line-height: 1;">√ó</button>
            <h2 style="color: var(--accent-primary); margin-bottom: 20px;">üîÑ Switch UI Version</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Choose which version of the UI you want to use:
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="switchToVersion('v1')" class="version-btn" style="background: #00d4ff;">
                    üì• Feedbacks Collection
                </button>
                <button onclick="switchToVersion('v2')" class="version-btn" style="background: #34d399;">
                    üìä Dashboard Analytics
                </button>
            </div>
            <p style="color: var(--text-muted); font-size: 0.9em; margin-top: 20px; text-align: center;">
                The page will reload after switching.
            </p>
        </div>
    </div>

    <script>
        // D√©tection automatique de l'URL du backend
        function getApiBase() {
            // Si on est sur localhost, utiliser le port 8000 par d√©faut
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                return `http://${window.location.hostname}:8000`;
            }
            // Sinon, utiliser le m√™me hostname et port que la page actuelle
            // Si le port est dans l'URL, l'utiliser, sinon utiliser le port par d√©faut 11840 pour Docker OVH
            const port = window.location.port || '11840';
            return `${window.location.protocol}//${window.location.hostname}:${port}`;
        }
        
        const API_BASE = getApiBase();
        
        // Theme Management
        function toggleTheme() {
            const body = document.body;
            const isDark = body.classList.contains('dark-mode');
            
            if (isDark) {
                body.classList.remove('dark-mode');
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-mode');
                localStorage.setItem('theme', 'dark');
            }
            
            // Dispatch event to notify other pages
            window.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme: isDark ? 'light' : 'dark' } }));
        }
        
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            
            // Listen for theme changes from other pages
            window.addEventListener('storage', (e) => {
                if (e.key === 'theme') {
                    if (e.newValue === 'dark') {
                        document.body.classList.add('dark-mode');
                    } else {
                        document.body.classList.remove('dark-mode');
                    }
                }
            });
            
            // Listen for theme change events
            window.addEventListener('themeChanged', (e) => {
                if (e.detail.theme === 'dark') {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
            });
        }
        
        // Load and display version
        async function loadVersion() {
            try {
                const response = await fetch(`${API_BASE}/api/version`);
                if (response.ok) {
                    const data = await response.json();
                    const versionBadge = document.getElementById('versionBadge');
                    if (versionBadge) {
                        versionBadge.textContent = `v${data.version}`;
                        versionBadge.title = `Version ${data.version} - Build: ${new Date(data.build_date).toLocaleDateString()}`;
                    }
                }
            } catch (error) {
                console.warn('Failed to load version:', error);
            }
        }
        
        // Initialize theme on page load
        initializeTheme();
        
        // Load version on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadVersion);
        } else {
            loadVersion();
        }
        
        // Make toggleTheme available globally
        window.toggleTheme = toggleTheme;
        
        let timelineChart = null;
        let productPieChart = null;
        let chartView = 'bar'; // 'bar' or 'line'
        let backlogView = 'card'; // 'card' or 'list'
        let selectedProducts = new Set(); // Multi-selection for products
        let selectedSentiments = new Set(); // Multi-selection for sentiments

        // LocalStorage for persistent filters
        function saveFilters() {
            const filters = {
                searchInput: document.getElementById('searchInput').value,
                ovhProductFilter: document.getElementById('ovhProductFilter').value,
                sourceFilter: document.getElementById('sourceFilter').value,
                sentimentFilter: document.getElementById('sentimentFilter').value,
                dateFrom: document.getElementById('dateFrom').value,
                dateTo: document.getElementById('dateTo').value,
            };
            localStorage.setItem('ovhTrackerFilters', JSON.stringify(filters));
        }

        function loadFilters() {
            const saved = localStorage.getItem('ovhTrackerFilters');
            if (saved) {
                try {
                    const filters = JSON.parse(saved);
                    const searchInput = document.getElementById('searchInput');
                    const keywordFilter = document.getElementById('keywordFilter');
                    const sourceFilter = document.getElementById('sourceFilter');
                    const sentimentFilter = document.getElementById('sentimentFilter');
                    const dateFrom = document.getElementById('dateFrom');
                    const dateTo = document.getElementById('dateTo');
                    
                    if (searchInput) searchInput.value = filters.searchInput || '';
                    if (keywordFilter) keywordFilter.value = filters.keywordFilter || '';
                    if (sourceFilter) sourceFilter.value = filters.sourceFilter || '';
                    if (sentimentFilter) sentimentFilter.value = filters.sentimentFilter || '';
                    if (dateFrom) dateFrom.value = filters.dateFrom || '';
                    if (dateTo) dateTo.value = filters.dateTo || '';
                    console.log('‚úÖ Filters restored from localStorage');
                } catch (e) {
                    console.log('Could not restore filters:', e);
                }
            }
        }

        // Logs management
        let logs = [];
        
        // Logs functions removed - use dedicated /logs page instead
        // All addLog() calls have been replaced with console.log() or removed
        function addLog() { /* Removed - use /logs page */ }
        function showLogs() { /* Removed - use /logs page */ }
        function clearLogs() { /* Removed - use /logs page */ }
        function hideLogs() { /* Removed - use /logs page */ }

        // Toast notifications
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            let icon = '‚ú®';
            if (type === 'error') icon = '‚ùå';
            if (type === 'info') icon = '‚ÑπÔ∏è';
            
            toast.innerHTML = `${icon} ${message}`;
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.add('hide');
                setTimeout(() => {
                    toast.remove();
                }, 500);
            }, 3000);
        }

        // Mock data for demo
        const mockPosts = [
            {
                id: 1,
                source: 'x',
                author: '@complainingcustomer',
                content: 'OVH domain transfer failed again! Been trying for 3 days. Their support is non-responsive. This is unacceptable!',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T15:30:00',
                sentiment_score: -0.85,
                sentiment_label: 'negative'
            },
            {
                id: 2,
                source: 'reddit',
                author: 'frustrated_user_123',
                content: 'Just experienced a domain renewal issue with OVH. The automatic renewal charge twice. Waiting for refund...',
                url: 'https://reddit.com/r/...',
                created_at: '2026-01-13T14:20:00',
                sentiment_score: -0.72,
                sentiment_label: 'negative'
            },
            {
                id: 3,
                source: 'x',
                author: '@happycustomer',
                content: 'Finally got my OVH domain working smoothly! Customer support helped me out. Great service overall!',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T13:10:00',
                sentiment_score: 0.68,
                sentiment_label: 'positive'
            },
            {
                id: 4,
                source: 'reddit',
                author: 'dev_community',
                content: 'OVH domains are decent but their DNS settings could be clearer in the UI. Not terrible, not amazing.',
                url: 'https://reddit.com/r/...',
                created_at: '2026-01-13T12:00:00',
                sentiment_score: 0.12,
                sentiment_label: 'neutral'
            },
            {
                id: 5,
                source: 'x',
                author: '@techblogger',
                content: 'OVH support response time is getting worse. Their ticketing system is broken. Many customers complaining.',
                url: 'https://twitter.com/...',
                created_at: '2026-01-13T11:00:00',
                sentiment_score: -0.78,
                sentiment_label: 'negative'
            },
        ];

        let allPosts = [];
        let currentOffset = 0;
        const postsPerPage = 20;

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        function getSentimentClass(label) {
            return `sentiment sentiment-${label}`;
        }

        function getSourceClass(source) {
            return `post-source source-${source}`;
        }
        
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Store for manually edited product labels (post_id -> label)
        function saveProductLabel(postId, label) {
            const labels = loadProductLabels();
            if (label && label.trim()) {
                labels[postId] = label.trim();
            } else {
                delete labels[postId]; // Remove if empty
            }
            localStorage.setItem('ovh_product_labels', JSON.stringify(labels));
        }
        
        function loadProductLabels() {
            const saved = localStorage.getItem('ovh_product_labels');
            return saved ? JSON.parse(saved) : {};
        }
        
        function getProductLabel(postId, postContent, postLanguage) {
            // First check if there's a manually edited label
            const editedLabels = loadProductLabels();
            if (editedLabels[postId]) {
                return editedLabels[postId];
            }
            
            // Otherwise detect automatically
            const detectedProduct = detectOVHProduct(postContent);
            if (detectedProduct) {
                return detectedProduct;
            }
            
            // Fallback to language if not unknown
            if (postLanguage && postLanguage !== 'unknown') {
                return postLanguage.toUpperCase();
            }
            
            return null;
        }
        
        function detectOVHProduct(postContent) {
            if (!postContent) return null;
            
            const content = postContent.toLowerCase();
            
            // Product patterns with priority order (more specific first)
            // Note: "support" is now lower priority to avoid false positives
            const productPatterns = [
                // Web & Hosting
                { key: 'domain', pattern: /\b(domain|domaine|dns|zone|registrar|nameserver)\w*/i, label: 'üåê Domain' },
                { key: 'wordpress', pattern: /\b(wordpress|wp\s*host)\w*/i, label: 'üìù WordPress' },
                { key: 'email', pattern: /\b(email|exchange|mail|mx|zimbra|smtp|imap)\w*/i, label: 'üìß Email' },
                { key: 'web-hosting', pattern: /\b(web\s*host|hosting|h√©bergement|mutualis√©|shared\s*host)\w*/i, label: 'üåê Web Hosting' },
                
                // Cloud & Servers
                { key: 'vps', pattern: /\b(vps|virtual\s*private\s*server)\w*/i, label: '‚òÅÔ∏è VPS' },
                { key: 'dedicated', pattern: /\b(dedicated|d√©di√©|bare\s*metal|server\s*dedicated)\w*/i, label: 'üñ•Ô∏è Dedicated' },
                { key: 'public-cloud', pattern: /\b(public\s*cloud|openstack|instance|compute)\w*/i, label: '‚òÅÔ∏è Public Cloud' },
                { key: 'private-cloud', pattern: /\b(private\s*cloud|vmware)\w*/i, label: 'üîí Private Cloud' },
                { key: 'hosted-private-cloud', pattern: /\b(hosted\s*private\s*cloud|hpc)\w*/i, label: 'üè¢ Hosted Private Cloud' },
                
                // Storage & Backup
                { key: 'object-storage', pattern: /\b(object\s*storage|swift|s3|storage)\w*/i, label: 'üíæ Object Storage' },
                { key: 'cloud-archive', pattern: /\b(cloud\s*archive|archive)\w*/i, label: 'üì¶ Archive' },
                { key: 'nas-ha', pattern: /\b(nas|nas-ha)\w*/i, label: 'üíæ NAS' },
                { key: 'veeam', pattern: /\b(veeam|backup)\w*/i, label: 'üíæ Backup' },
                
                // Network & CDN
                { key: 'cdn', pattern: /\b(cdn|content\s*delivery)\w*/i, label: 'üåç CDN' },
                { key: 'load-balancer', pattern: /\b(load\s*balancer|iplb)\w*/i, label: '‚öñÔ∏è Load Balancer' },
                { key: 'ddos', pattern: /\b(ddos|anti-ddos|protection)\w*/i, label: 'üõ°Ô∏è DDoS Protection' },
                { key: 'vrack', pattern: /\b(vrack|private\s*network)\w*/i, label: 'üîó vRack' },
                
                // Telecom
                { key: 'voip', pattern: /\b(voip|telephony|t√©l√©phonie|sip)\w*/i, label: 'üìû VoIP' },
                { key: 'sms', pattern: /\b(sms|text\s*message)\w*/i, label: 'üí¨ SMS' },
                { key: 'fax', pattern: /\b(fax|fax2mail)\w*/i, label: 'üì† Fax' },
                
                // Support & Billing (lower priority - only if no other product found)
                { key: 'billing', pattern: /\b(billing|facture|invoice|payment|paiement|refund|rembours)\w*/i, label: 'üí≥ Billing' },
                { key: 'manager', pattern: /\b(manager|control\s*panel|espace\s*client)\w*/i, label: '‚öôÔ∏è Manager' },
                { key: 'api', pattern: /\b(api|sdk|integration)\w*/i, label: 'üîå API' },
                { key: 'support', pattern: /\b(support|ticket|assistance|help|service\s*client)\w*/i, label: 'üé´ Support' },
            ];
            
            // Check patterns in order (first match wins)
            for (const product of productPatterns) {
                if (product.pattern.test(content)) {
                    return product.label;
                }
            }
            
            return null; // No product detected
        }
        
        function editProductLabel(postId, currentLabel) {
            const newLabel = prompt(`Edit product label for post #${postId}:\n\nCurrent: ${currentLabel || '(none)'}\n\nEnter new label (or leave empty to remove):`, currentLabel || '');
            
            if (newLabel !== null) { // User didn't cancel
                saveProductLabel(postId, newLabel);
                renderGallery(); // Refresh to show updated label
                showToast('Product label updated', 'success');
            }
        }

        async function loadPostsFromDB() {
            try {
                const response = await fetch(`${API_BASE}/posts?limit=1000`);
                if (response.ok) {
                    const posts = await response.json();
                    // Filter out sample posts
                    allPosts = posts.filter(post => {
                        const url = post.url || '';
                        const isSample = (
                            url.includes('/sample') || 
                            url.includes('example.com') ||
                            url.includes('/status/174') ||
                            url === 'https://trustpilot.com/sample'
                        );
                        return !isSample;
                    });
                    renderGallery();
                    updateActiveFiltersCount();
                    return true;
                } else {
                    console.error('Failed to load posts');
                    return false;
                }
            } catch (e) {
                console.error(`Error loading posts: ${e.message}`);
                return false;
            }
        }
        
        async function cleanupDuplicates() {
            const confirmed = confirm(
                'üîÑ Remove Duplicate Posts\n\n' +
                'This will remove duplicate posts identified by:\n' +
                '‚Ä¢ Same URL\n' +
                '‚Ä¢ Same content + author + source\n\n' +
                '‚úÖ The oldest post (lowest ID) is kept\n' +
                '‚ùå Duplicates are deleted\n\n' +
                'This action is IRREVERSIBLE.\n\n' +
                'Do you want to continue?'
            );
            
            if (!confirmed) {
                return;
            }
            
            try {
                console.log('Cleaning up duplicate posts...');
                showToast('Removing duplicate posts from database...', 'info');
                
                const response = await fetch(`${API_BASE}/admin/cleanup-duplicates`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`‚úÖ ${data.deleted} duplicate posts deleted from database`);
                    showToast(`Successfully removed ${data.deleted} duplicate posts`, 'success');
                    
                    // Reload posts after cleanup
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    const errorText = await response.text();
                    console.error(`Error: ${errorText}`);
                    showToast(`Error: ${errorText}`, 'error');
                }
            } catch (e) {
                console.error(`Error cleaning duplicates: ${e.message}`);
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        async function cleanupNonOvhPosts() {
            const confirmed = confirm(
                '‚ö†Ô∏è WARNING: This action will delete ALL posts that do NOT mention OVH!\n\n' +
                '‚úÖ Posts kept: Those containing "ovh", "ovhcloud", "ovh cloud", "kimsufi" or "soyoustart"\n' +
                '‚ùå Posts deleted: All others\n\n' +
                'This action is IRREVERSIBLE.\n\n' +
                'Do you want to continue?'
            );
            
            if (!confirmed) {
                return;
            }
            
            try {
                console.log('Cleaning up non-OVH posts...');
                showToast('Removing non-OVH posts from database...', 'info');
                
                const response = await fetch(`${API_BASE}/admin/cleanup-non-ovh-posts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`‚úÖ ${data.deleted} non-OVH posts deleted from database`);
                    showToast(`Successfully removed ${data.deleted} non-OVH posts`, 'success');
                    
                    // Reload posts after cleanup
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    const errorText = await response.text();
                    console.error(`Error: ${errorText}`);
                    showToast(`Error: ${errorText}`, 'error');
                    console.error('Cleanup non-OVH posts error:', errorText);
                }
            } catch (e) {
                console.error(`Error during cleanup: ${e.message}`);
                showToast(`Error: ${e.message}`, 'error');
                console.error('Cleanup non-OVH posts exception:', e);
            }
        }
        
        function applyDateFilter() {
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;
            
            if (!dateFrom && !dateTo) {
                alert('Please select at least one date');
                return;
            }
            
            if (dateFrom && dateTo && dateFrom > dateTo) {
                alert('Start date must be before end date');
                return;
            }
            
            const fromDisplay = dateFrom ? new Date(dateFrom).toLocaleDateString('fr-FR') : 'any date';
            const toDisplay = dateTo ? new Date(dateTo).toLocaleDateString('fr-FR') : 'today';
            
            console.log(`Filtering from ${fromDisplay} to ${toDisplay}`);
            currentOffset = 0;
            
            // Just reload data from DB without scraping
            renderGallery();
            showToast('Timeline filters applied', 'info');
        }
        
        function getAvailableProductLabels() {
            // Get all unique product labels that exist in the database
            const labels = new Set();
            
            allPosts.forEach(post => {
                // Skip sample posts
                const url = post.url || '';
                const isSample = (
                    url.includes('/sample') || 
                    url.includes('example.com') ||
                    url.includes('/status/174') ||
                    url === 'https://trustpilot.com/sample'
                );
                if (isSample) return;
                
                // Get product label (with manual edit support)
                const productLabel = getProductLabel(post.id, post.content, post.language);
                if (productLabel) {
                    labels.add(productLabel);
                }
            });
            
            return Array.from(labels).sort();
        }
        
        function updateChartProductFilter() {
            // Update the product filter dropdown with available labels
            const productFilter = document.getElementById('chartProductFilter');
            if (!productFilter) return;
            
            const currentValue = productFilter.value;
            const availableLabels = getAvailableProductLabels();
            
            // Clear existing options except "All Products"
            productFilter.innerHTML = '<option value="all">All Products</option>';
            
            // Add available product labels
            availableLabels.forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                productFilter.appendChild(option);
            });
            
            // Restore previous selection if it still exists
            if (currentValue && currentValue !== 'all') {
                const option = Array.from(productFilter.options).find(opt => opt.value === currentValue);
                if (option) {
                    productFilter.value = currentValue;
                }
            }
        }
        
        function openChartModal() {
            document.getElementById('chartModal').style.display = 'block';
            // Sync dates from main filters to chart filters
            document.getElementById('chartDateFrom').value = document.getElementById('dateFrom').value;
            document.getElementById('chartDateTo').value = document.getElementById('dateTo').value;
            // Update product filter with available labels
            updateChartProductFilter();
            // Wait for modal to be visible, then update chart
            setTimeout(() => {
                // Ensure allPosts is loaded
                if (allPosts.length === 0) {
                    console.warn('No posts loaded, loading from DB...');
                    loadPostsFromDB().then(() => {
                        updateChart();
                    }).catch(err => {
                        console.error('Failed to load posts:', err);
                        console.error('Failed to load posts for charts');
                    });
                } else {
                    updateChart();
                }
            }, 100);
        }
        
        function closeChartModal() {
            document.getElementById('chartModal').style.display = 'none';
            // Destroy charts when modal closes to free memory
            if (productPieChart) {
                productPieChart.destroy();
                productPieChart = null;
            }
        }
        
        function syncDateFiltersFromChart() {
            // Sync chart date filters to main filters
            const chartDateFrom = document.getElementById('chartDateFrom').value;
            const chartDateTo = document.getElementById('chartDateTo').value;
            
            document.getElementById('dateFrom').value = chartDateFrom;
            document.getElementById('dateTo').value = chartDateTo;
        }
        
        function applyChartDateFilter() {
            syncDateFiltersFromChart();
            updateChart();
            renderGallery(); // Also update main gallery
            showToast('Timeline filter applied', 'success');
        }
        
        function clearChartDates() {
            document.getElementById('chartDateFrom').value = '';
            document.getElementById('chartDateTo').value = '';
            document.getElementById('dateFrom').value = '';
            document.getElementById('dateTo').value = '';
            updateChart();
            renderGallery();
            showToast('Timeline filter cleared', 'info');
        }
        
        function openStatsInfoModal() {
            document.getElementById('statsInfoModal').style.display = 'block';
        }
        
        function closeStatsInfoModal() {
            document.getElementById('statsInfoModal').style.display = 'none';
        }
        
        function openPostPreview(postId) {
            // Find the post in allPosts
            const post = allPosts.find(p => p.id === postId);
            if (!post) {
                showToast('Post not found', 'error');
                return;
            }
            
            const modal = document.getElementById('postPreviewModal');
            const contentDiv = document.getElementById('postPreviewContent');
            const linkDiv = document.getElementById('postPreviewLink');
            
            if (!modal || !contentDiv || !linkDiv) return;
            
            // Get product label
            const productLabel = getProductLabel(post.id, post.content, post.language);
            
            // Format date
            const postDate = new Date(post.created_at).toLocaleString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Build content HTML
            contentDiv.innerHTML = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <strong style="color: var(--accent-primary); font-size: 1.1em;">${escapeHtml(post.source || 'Unknown Source')}</strong>
                            ${productLabel ? `<span style="margin-left: 10px; padding: 4px 8px; background: rgba(52, 211, 153, 0.2); border-radius: 4px; color: #34d399; font-size: 0.9em;">${escapeHtml(productLabel)}</span>` : ''}
                        </div>
                        <span class="${getSentimentClass(post.sentiment_label)}" style="font-size: 0.95em;">
                            ${post.sentiment_label.toUpperCase()} (${(post.sentiment_score).toFixed(2)})
                        </span>
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">
                        <strong>Author:</strong> ${escapeHtml(post.author || 'Unknown')}
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">
                        <strong>Date:</strong> ${postDate}
                    </div>
                    ${post.language ? `<div style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">
                        <strong>Language:</strong> ${escapeHtml(post.language.toUpperCase())}
                    </div>` : ''}
                </div>
                
                <div style="padding: 20px; background: var(--bg-card); border-radius: 8px; border: 1px solid rgba(0, 212, 255, 0.2);">
                    <h3 style="color: var(--accent-primary); margin-top: 0; margin-bottom: 15px; font-size: 1.2em;">Content:</h3>
                    <div style="color: var(--text-primary); white-space: pre-wrap; word-wrap: break-word; line-height: 1.6; max-height: 500px; overflow-y: auto;">
                        ${escapeHtml(post.content || 'No content available')}
                    </div>
                </div>
            `;
            
            // Set link
            linkDiv.href = post.url || '#';
            if (!post.url || post.url === '#') {
                linkDiv.style.display = 'none';
            } else {
                linkDiv.style.display = 'inline-block';
            }
            
            // Show modal
            modal.style.display = 'block';
        }
        
        function closePostPreviewModal() {
            document.getElementById('postPreviewModal').style.display = 'none';
        }
        
        async function refreshChartData() {
            console.log('Refreshing chart data...');
            const success = await loadPostsFromDB();
            if (success) {
                updateChartProductFilter(); // Update product filter with new data
                updateChart();
                showToast('Chart data refreshed from database', 'success');
            } else {
                showToast('Failed to refresh chart data', 'error');
            }
        }
        
        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            const chartModal = document.getElementById('chartModal');
            const statsModal = document.getElementById('statsInfoModal');
            const postPreviewModal = document.getElementById('postPreviewModal');
            const filteredPostsModal = document.getElementById('filteredPostsModal');
            
            if (chartModal && event.target === chartModal) {
                closeChartModal();
            }
            if (statsModal && event.target === statsModal) {
                closeStatsInfoModal();
            }
            if (postPreviewModal && event.target === postPreviewModal) {
                closePostPreviewModal();
            }
            if (filteredPostsModal && event.target === filteredPostsModal) {
                closeFilteredPostsModal();
            }
            const ideasModal = document.getElementById('ideasModal');
            if (ideasModal && event.target === ideasModal) {
                closeIdeasModal();
            }
        });
        
        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const chartModal = document.getElementById('chartModal');
                const statsModal = document.getElementById('statsInfoModal');
                const postPreviewModal = document.getElementById('postPreviewModal');
                const ideasModal = document.getElementById('ideasModal');
                const filteredPostsModal = document.getElementById('filteredPostsModal');
                
                if (filteredPostsModal && filteredPostsModal.style.display !== 'none') {
                    closeFilteredPostsModal();
                } else if (ideasModal && ideasModal.style.display !== 'none') {
                    closeIdeasModal();
                } else if (postPreviewModal && postPreviewModal.style.display !== 'none') {
                    closePostPreviewModal();
                } else if (chartModal && chartModal.style.display !== 'none') {
                    closeChartModal();
                } else if (statsModal && statsModal.style.display !== 'none') {
                    closeStatsInfoModal();
                }
            }
        });

        function clearAllFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('sourceFilter').value = '';
            document.getElementById('sentimentFilter').value = '';
            document.getElementById('ovhProductFilter').value = '';
            document.getElementById('languageFilter').value = '';
            document.getElementById('dateFrom').value = '';
            document.getElementById('dateTo').value = '';
            document.getElementById('sortBy').value = 'date-desc';
            currentOffset = 0;
            console.log('All filters cleared');
            updateActiveFiltersCount();
            renderGallery();
        }

        function renderGallery() {
            const gallery = document.getElementById('gallery');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const sourceFilter = document.getElementById('sourceFilter').value;
            const sentimentFilter = document.getElementById('sentimentFilter').value;
            const ovhProductFilter = document.getElementById('ovhProductFilter').value;
            const languageFilter = document.getElementById('languageFilter').value;
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;

            // Define OVH product patterns
            const ovhProductPatterns = {
                // Web & Hosting
                'web-hosting': /\b(web\s*host|hosting|h√©bergement|mutualis√©|shared\s*host)\w*/i,
                'wordpress': /\b(wordpress|wp\s*host)\w*/i,
                'email': /\b(email|exchange|mail|mx|zimbra)\w*/i,
                'domain': /\b(domain|domaine|dns|zone|registrar)\w*/i,
                
                // Cloud & Servers
                'vps': /\b(vps|virtual\s*private\s*server)\w*/i,
                'dedicated': /\b(dedicated|d√©di√©|bare\s*metal)\w*/i,
                'public-cloud': /\b(public\s*cloud|openstack|instance)\w*/i,
                'private-cloud': /\b(private\s*cloud|vmware)\w*/i,
                'hosted-private-cloud': /\b(hosted\s*private\s*cloud|hpc)\w*/i,
                
                // Storage & Backup
                'object-storage': /\b(object\s*storage|swift|s3)\w*/i,
                'cloud-archive': /\b(cloud\s*archive|archive)\w*/i,
                'nas-ha': /\b(nas|nas-ha)\w*/i,
                'veeam': /\b(veeam|backup)\w*/i,
                
                // Network & CDN
                'cdn': /\b(cdn|content\s*delivery)\w*/i,
                'load-balancer': /\b(load\s*balancer|iplb)\w*/i,
                'ddos': /\b(ddos|anti-ddos|protection)\w*/i,
                'vrack': /\b(vrack|private\s*network)\w*/i,
                
                // Telecom
                'voip': /\b(voip|telephony|t√©l√©phonie|sip)\w*/i,
                'sms': /\b(sms|text\s*message)\w*/i,
                'fax': /\b(fax|fax2mail)\w*/i,
                
                // Support & Billing
                'support': /\b(support|ticket|assistance|help)\w*/i,
                'billing': /\b(billing|facture|invoice|payment|paiement|refund|rembours)\w*/i,
                'manager': /\b(manager|control\s*panel|espace\s*client)\w*/i,
                'api': /\b(api|sdk|integration)\w*/i,
            };

            let filtered = allPosts.filter(post => {
                // Filter out sample data first
                const isSample = post.url && (
                    post.url.includes('/sample') || 
                    post.url.includes('example.com') ||
                    post.url.includes('/status/174') ||
                    post.url === 'https://trustpilot.com/sample'
                );
                if (isSample) {
                    return false;
                }
                
                const postContent = post.content.toLowerCase();
                const postUrl = (post.url || '').toLowerCase();
                const postAuthor = (post.author || '').toLowerCase();
                
                // Improved search: check content, author, AND url
                const matchesSearch = !searchTerm || 
                    postContent.includes(searchTerm) || 
                    postAuthor.includes(searchTerm) ||
                    postUrl.includes(searchTerm);
                    
                const matchesSource = !sourceFilter || post.source === sourceFilter;
                const matchesSentiment = !sentimentFilter || post.sentiment_label === sentimentFilter;
                const matchesLanguage = !languageFilter || post.language === languageFilter;
                
                // OVH Product filter - only applies if a product is selected
                let matchesProduct = true;
                if (ovhProductFilter && ovhProductPatterns[ovhProductFilter]) {
                    matchesProduct = ovhProductPatterns[ovhProductFilter].test(post.content);
                }
                
                // Date range filter
                let matchesDate = true;
                if (dateFrom || dateTo) {
                    const postDate = new Date(post.created_at).toISOString().split('T')[0];
                    if (dateFrom && postDate < dateFrom) matchesDate = false;
                    if (dateTo && postDate > dateTo) matchesDate = false;
                }
                
                return matchesSearch && matchesSource && matchesSentiment && matchesProduct && matchesDate && matchesLanguage;
            });

            // Debug log to track filtering
            if (allPosts.length !== filtered.length) {
                console.log(`[FILTER] ${allPosts.length} total posts -> ${filtered.length} after filters`, {
                    search: searchTerm || 'none',
                    source: sourceFilter || 'all',
                    sentiment: sentimentFilter || 'all',
                    product: ovhProductFilter || 'all',
                    language: languageFilter || 'all',
                    dateRange: (dateFrom || dateTo) ? `${dateFrom || '*'} to ${dateTo || '*'}` : 'all'
                });
            }

            updateStats(filtered);

            if (filtered.length === 0) {
                const activeFilters = [];
                if (searchTerm) activeFilters.push(`Search: "${searchTerm}"`);
                if (sourceFilter) activeFilters.push(`Source: ${sourceFilter}`);
                if (sentimentFilter) activeFilters.push(`Sentiment: ${sentimentFilter}`);
                if (ovhProductFilter) activeFilters.push(`Product: ${ovhProductFilter}`);
                if (languageFilter) activeFilters.push(`Language: ${languageFilter}`);
                if (dateFrom || dateTo) activeFilters.push(`Date: ${dateFrom || '*'} to ${dateTo || '*'}`);
                
                const filterInfo = activeFilters.length > 0 
                    ? `<p style="color:#ff9800;">Active filters hiding ${allPosts.length} posts:</p><ul style="text-align:left; max-width:500px; margin:15px auto;">${activeFilters.map(f => `<li>${f}</li>`).join('')}</ul><button onclick="clearAllFilters()" style="margin-top:15px; padding:12px 24px; background:#00d4ff; border:none; border-radius:8px; color:#1a1a2e; font-weight:bold; cursor:pointer;">Clear all filters</button>`
                    : `<p>Try scraping data or adjusting your filters.</p>`;
                
                gallery.innerHTML = `<div class="empty-state"><h2>No posts found</h2>${filterInfo}</div>`;
                return;
            }

            // Apply sorting
            const sortBy = document.getElementById('sortBy')?.value || 'date-desc';
            if (sortBy === 'date-desc') {
                filtered.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            } else if (sortBy === 'date-asc') {
                filtered.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            } else if (sortBy === 'sentiment-desc') {
                filtered.sort((a, b) => a.sentiment_score - b.sentiment_score);
            } else if (sortBy === 'sentiment-asc') {
                filtered.sort((a, b) => b.sentiment_score - a.sentiment_score);
            } else if (sortBy === 'source-asc') {
                filtered.sort((a, b) => a.source.localeCompare(b.source));
            } else if (sortBy === 'source-desc') {
                filtered.sort((a, b) => b.source.localeCompare(a.source));
            }

            // Pagination
            const totalPosts = filtered.length;
            const paginated = filtered.slice(currentOffset, currentOffset + postsPerPage);

            gallery.innerHTML = paginated.map(post => {
                // Filter out sample data - don't display posts with sample URLs
                const isSample = post.url && (
                    post.url.includes('/sample') || 
                    post.url.includes('example.com') ||
                    post.url.includes('/status/174') ||
                    post.url === 'https://trustpilot.com/sample'
                );
                
                // Skip sample posts entirely
                if (isSample) {
                    return '';
                }
                
                // Get product label (with manual edit support)
                const productLabel = getProductLabel(post.id, post.content, post.language);
                
                return `
                <div class="post-card">
                    <div class="post-header">
                        <span class="${getSourceClass(post.source)}">${escapeHtml(post.source)}</span>
                        <span class="post-date">${formatDate(post.created_at)}</span>
                        ${productLabel ? `
                            <span style="font-size:0.75em; background:rgba(0,212,255,0.2); padding:4px 8px; border-radius:4px; margin-left:5px; display:inline-flex; align-items:center; gap:4px;">
                                ${escapeHtml(productLabel)}
                                <button onclick="editProductLabel(${post.id}, '${escapeHtml(productLabel).replace(/'/g, "\\'")}')" 
                                        style="background:none; border:none; color:var(--accent-primary); cursor:pointer; padding:0; margin:0; font-size:0.9em; opacity:0.7;"
                                        title="Edit product label">‚úèÔ∏è</button>
                            </span>
                        ` : `
                            <button onclick="editProductLabel(${post.id}, '')" 
                                    style="font-size:0.75em; background:rgba(0,212,255,0.1); padding:4px 8px; border-radius:4px; margin-left:5px; border:1px dashed rgba(0,212,255,0.3); color:var(--accent-primary); cursor:pointer;"
                                    title="Add product label">+ Label</button>
                        `}
                    </div>
                    <div class="post-author">@${escapeHtml(post.author)}</div>
                    <div class="post-content">${escapeHtml(post.content)}</div>
                    <div class="post-footer">
                        <span class="${getSentimentClass(post.sentiment_label)}">
                            ${post.sentiment_label.toUpperCase()} (${(post.sentiment_score).toFixed(2)})
                        </span>
                        <button onclick="openPostPreview(${post.id})" style="margin-left:10px; padding:6px 12px; background:#34d399; border:none; border-radius:6px; color:#1a1a2e; cursor:pointer; font-weight:500;">üëÅÔ∏è Preview</button>
                        <a href="${escapeHtml(post.url)}" target="_blank" class="post-url" style="margin-left:10px;">View</a>
                        <button onclick="addToBacklog(${post.id})" style="margin-left:10px; padding:6px 12px; background:#0099ff; border:none; border-radius:6px; color:#fff; cursor:pointer;">Save</button>
                    </div>
                </div>
            `}).filter(html => html !== '').join('');

            // Add load more button if there are more posts
            if (currentOffset + postsPerPage < totalPosts) {
                // Remove existing load more button if any
                const existingLoadMore = gallery.querySelector('.load-more-container');
                if (existingLoadMore) {
                    existingLoadMore.remove();
                }
                
                const loadMoreDiv = document.createElement('div');
                loadMoreDiv.className = 'load-more-container';
                loadMoreDiv.style.textAlign = 'center';
                loadMoreDiv.style.marginTop = '30px';
                loadMoreDiv.style.gridColumn = '1 / -1';
                loadMoreDiv.style.minHeight = '60px'; // Fixed height to prevent layout shift
                loadMoreDiv.style.display = 'flex';
                loadMoreDiv.style.alignItems = 'center';
                loadMoreDiv.style.justifyContent = 'center';
                
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.onclick = loadMorePosts;
                loadMoreBtn.style.padding = '12px 30px';
                loadMoreBtn.style.background = '#00d4ff';
                loadMoreBtn.style.color = '#1a1a2e';
                loadMoreBtn.style.border = 'none';
                loadMoreBtn.style.borderRadius = '8px';
                loadMoreBtn.style.cursor = 'pointer';
                loadMoreBtn.style.fontWeight = 'bold';
                loadMoreBtn.style.fontSize = '1em';
                loadMoreBtn.style.minWidth = '200px'; // Fixed width to prevent size changes
                loadMoreBtn.textContent = `üì• Load More (${currentOffset + postsPerPage}/${totalPosts})`;
                loadMoreDiv.appendChild(loadMoreBtn);
                gallery.appendChild(loadMoreDiv);
            } else {
                // Remove load more button if no more posts
                const existingLoadMore = gallery.querySelector('.load-more-container');
                if (existingLoadMore) {
                    existingLoadMore.remove();
                }
            }
        }

        function loadMorePosts() {
            currentOffset += postsPerPage;
            renderGallery();
        }

        function updateStats(filteredPosts) {
            // Update FILTERED stats (current view)
            const total = filteredPosts.length;
            const positive = filteredPosts.filter(p => p.sentiment_label === 'positive').length;
            const negative = filteredPosts.filter(p => p.sentiment_label === 'negative').length;
            const neutral = filteredPosts.filter(p => p.sentiment_label === 'neutral').length;

            document.getElementById('totalPosts').textContent = total;
            document.getElementById('positivePosts').textContent = positive;
            document.getElementById('negativePosts').textContent = negative;
            document.getElementById('neutralPosts').textContent = neutral;
            
            // Update GLOBAL stats (all posts in DB)
            const allRealPosts = allPosts.filter(post => {
                const url = post.url || '';
                const isSample = (
                    url.includes('/sample') || 
                    url.includes('example.com') ||
                    url.includes('/status/174') ||
                    url === 'https://trustpilot.com/sample'
                );
                return !isSample;
            });
            
            const globalTotal = allRealPosts.length;
            const globalPositive = allRealPosts.filter(p => p.sentiment_label === 'positive').length;
            const globalNegative = allRealPosts.filter(p => p.sentiment_label === 'negative').length;
            const globalNeutral = allRealPosts.filter(p => p.sentiment_label === 'neutral').length;

            document.getElementById('globalTotalPosts').textContent = globalTotal;
            document.getElementById('globalPositivePosts').textContent = globalPositive;
            document.getElementById('globalNegativePosts').textContent = globalNegative;
            document.getElementById('globalNeutralPosts').textContent = globalNeutral;
        }
        
        function updateChart() {
            // Only update chart if modal is open and canvas exists
            const modal = document.getElementById('chartModal');
            const canvas = document.getElementById('timelineChart');
            if (!modal || modal.style.display === 'none' || !canvas) {
                return;
            }
            
            const sentimentFilter = document.getElementById('chartSentimentFilter')?.value || 'all';
            const productFilter = document.getElementById('chartProductFilter')?.value || 'all';
            const grouping = document.getElementById('chartGrouping')?.value || 'day';
            
            // Get date filters
            const dateFrom = document.getElementById('dateFrom')?.value;
            const dateTo = document.getElementById('dateTo')?.value;
            
            // Filter posts for chart
            let chartPosts = allPosts.filter(post => {
                const url = post.url || '';
                const isSample = (
                    url.includes('/sample') || 
                    url.includes('example.com') ||
                    url.includes('/status/174') ||
                    url === 'https://trustpilot.com/sample'
                );
                if (isSample) return false;
                
                // Apply date range if set
                if (dateFrom || dateTo) {
                    const postDate = new Date(post.created_at).toISOString().split('T')[0];
                    if (dateFrom && postDate < dateFrom) return false;
                    if (dateTo && postDate > dateTo) return false;
                }
                
                // Apply sentiment filter (support multi-selection)
                if (sentimentFilter !== 'all' || selectedSentiments.size > 0) {
                    // Check if we have multiple sentiments selected
                    if (selectedSentiments.size > 0) {
                        if (!selectedSentiments.has(post.sentiment_label)) {
                            return false;
                        }
                    } else if (post.sentiment_label !== sentimentFilter) {
                        return false;
                    }
                }
                
                // Apply product filter (support multi-selection)
                if (productFilter !== 'all' || selectedProducts.size > 0) {
                    const productLabel = getProductLabel(post.id, post.content, post.language);
                    const productValue = productLabel || '';
                    // Check if we have multiple products selected
                    if (selectedProducts.size > 0) {
                        if (!selectedProducts.has(productValue)) {
                            return false;
                        }
                    } else if (productLabel !== productFilter) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Group posts by time period
            const grouped = {};
            chartPosts.forEach(post => {
                const date = new Date(post.created_at);
                let key;
                
                if (grouping === 'day') {
                    key = date.toISOString().split('T')[0];
                } else if (grouping === 'week') {
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = weekStart.toISOString().split('T')[0];
                } else if (grouping === 'month') {
                    key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                }
                
                if (!grouped[key]) {
                    grouped[key] = { positive: 0, negative: 0, neutral: 0 };
                }
                grouped[key][post.sentiment_label]++;
            });
            
            // Sort by date
            const sortedKeys = Object.keys(grouped).sort();
            
            // Prepare chart data
            const labels = sortedKeys.map(key => {
                const date = new Date(key);
                if (grouping === 'day') return date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
                if (grouping === 'week') return `Week ${date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' })}`;
                return date.toLocaleDateString('fr-FR', { month: 'short', year: 'numeric' });
            });
            
            const positiveData = sortedKeys.map(key => grouped[key].positive);
            const negativeData = sortedKeys.map(key => grouped[key].negative);
            const neutralData = sortedKeys.map(key => grouped[key].neutral);
            
            // Destroy existing chart
            if (timelineChart) {
                timelineChart.destroy();
            }
            
            // Create new chart
            const ctx = document.getElementById('timelineChart');
            if (!ctx) return;
            
            const datasets = [];
            if (sentimentFilter === 'all' || sentimentFilter === 'negative') {
                datasets.push({
                    label: 'Negative',
                    data: negativeData,
                    backgroundColor: 'rgba(239, 68, 68, 0.7)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1
                });
            }
            if (sentimentFilter === 'all' || sentimentFilter === 'neutral') {
                datasets.push({
                    label: 'Neutral',
                    data: neutralData,
                    backgroundColor: 'rgba(107, 114, 128, 0.7)',
                    borderColor: 'rgba(107, 114, 128, 1)',
                    borderWidth: 1
                });
            }
            if (sentimentFilter === 'all' || sentimentFilter === 'positive') {
                datasets.push({
                    label: 'Positive',
                    data: positiveData,
                    backgroundColor: 'rgba(52, 211, 153, 0.7)',
                    borderColor: 'rgba(52, 211, 153, 1)',
                    borderWidth: 1
                });
            }
            
            timelineChart = new Chart(ctx, {
                type: chartView,
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const element = elements[0];
                            const index = element.index;
                            const clickedDate = labels[index];
                            
                            // Get the actual date key from sortedKeys (which is in scope)
                            const sortedKeys = Object.keys(grouped).sort();
                            const actualDateKey = sortedKeys[index];
                            
                            // Parse the date based on grouping
                            const grouping = document.getElementById('chartGrouping').value;
                            let dateFrom, dateTo;
                            
                            if (grouping === 'day') {
                                dateFrom = actualDateKey;
                                dateTo = actualDateKey;
                            } else if (grouping === 'week') {
                                // For week, we need to calculate the week range
                                const date = new Date(actualDateKey);
                                const dayOfWeek = date.getDay();
                                const diff = date.getDate() - dayOfWeek;
                                const weekStart = new Date(date);
                                weekStart.setDate(date.getDate() - dayOfWeek);
                                const weekEnd = new Date(weekStart);
                                weekEnd.setDate(weekStart.getDate() + 6);
                                dateFrom = weekStart.toISOString().split('T')[0];
                                dateTo = weekEnd.toISOString().split('T')[0];
                            } else if (grouping === 'month') {
                                // actualDateKey is in format "YYYY-MM" (e.g., "2026-01")
                                const parts = actualDateKey.split('-');
                                if (parts.length === 2) {
                                    const year = parseInt(parts[0]);
                                    const month = parseInt(parts[1]);
                                    const firstDay = new Date(year, month - 1, 1);
                                    const lastDay = new Date(year, month, 0);
                                    dateFrom = firstDay.toISOString().split('T')[0];
                                    dateTo = lastDay.toISOString().split('T')[0];
                                } else {
                                    // Fallback: treat as day
                                    dateFrom = actualDateKey;
                                    dateTo = actualDateKey;
                                }
                            }
                            
                            // Apply date filter
                            document.getElementById('dateFrom').value = dateFrom;
                            document.getElementById('dateTo').value = dateTo;
                            document.getElementById('chartDateFrom').value = dateFrom;
                            document.getElementById('chartDateTo').value = dateTo;
                            currentOffset = 0;
                            saveFilters();
                            renderGallery();
                            console.log(`Filtered by date: ${clickedDate}`);
                            showToast(`Filtered by date: ${clickedDate}`, 'info');
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary').trim() || '#fff'
                            }
                        },
                        title: {
                            display: true,
                            text: `Posts over time (${grouping}) - ${sentimentFilter === 'all' ? 'All Sentiments' : sentimentFilter.charAt(0).toUpperCase() + sentimentFilter.slice(1)}`,
                            color: getComputedStyle(document.body).getPropertyValue('--accent-primary').trim() || '#00d4ff'
                        }
                    },
                    scales: {
                        x: {
                            stacked: chartView === 'bar',
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-secondary').trim() || '#aaa',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: document.body.classList.contains('light-mode') ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        y: {
                            stacked: chartView === 'bar',
                            beginAtZero: true,
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-secondary').trim() || '#aaa',
                                stepSize: 1
                            },
                            grid: {
                                color: document.body.classList.contains('light-mode') ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'
                            }
                        }
                    }
                }
            });
            
            // Update product pie chart
            updateProductPieChart(chartPosts);
        }
        
        function updateProductPieChart(filteredPosts) {
            // Only update if modal is open and canvas exists
            const modal = document.getElementById('chartModal');
            const canvas = document.getElementById('productPieChart');
            if (!modal || modal.style.display === 'none' || !canvas) {
                return;
            }
            
            // Count posts by product
            const productCounts = {};
            let noProductCount = 0;
            
            filteredPosts.forEach(post => {
                const productLabel = getProductLabel(post.id, post.content, post.language);
                if (productLabel) {
                    productCounts[productLabel] = (productCounts[productLabel] || 0) + 1;
                } else {
                    noProductCount++;
                }
            });
            
            // Prepare data for pie chart
            const labels = Object.keys(productCounts);
            const data = Object.values(productCounts);
            
            // Add "Unknown" if there are posts without product label
            if (noProductCount > 0) {
                labels.push('No Product');
                data.push(noProductCount);
            }
            
            // Check if we have data to display
            if (labels.length === 0 || data.length === 0 || data.every(d => d === 0)) {
                console.warn('No product data to display in pie chart');
                // Destroy existing chart if any
                if (productPieChart) {
                    productPieChart.destroy();
                    productPieChart = null;
                }
                // Show empty message
                const pieContainer = canvas.parentElement;
                if (pieContainer) {
                    // Remove existing empty message if any
                    const existingMsg = pieContainer.querySelector('.empty-pie-msg');
                    if (existingMsg) existingMsg.remove();
                    
                    const emptyMsg = document.createElement('p');
                    emptyMsg.className = 'empty-pie-msg';
                    emptyMsg.style.cssText = 'color: var(--text-muted); text-align: center; padding: 40px; font-style: italic;';
                    emptyMsg.textContent = 'No product data available. Try adjusting filters or scrape new data.';
                    pieContainer.appendChild(emptyMsg);
                }
                return;
            }
            
            // Remove empty message if it exists
            const pieContainer = canvas.parentElement;
            if (pieContainer) {
                const existingMsg = pieContainer.querySelector('.empty-pie-msg');
                if (existingMsg) existingMsg.remove();
            }
            
            // Generate colors for each product
            const colors = [
                'rgba(0, 212, 255, 0.7)',   // Cyan
                'rgba(52, 211, 153, 0.7)',   // Green
                'rgba(239, 68, 68, 0.7)',   // Red
                'rgba(251, 191, 36, 0.7)',  // Yellow
                'rgba(139, 92, 246, 0.7)',  // Purple
                'rgba(236, 72, 153, 0.7)',  // Pink
                'rgba(34, 197, 94, 0.7)',   // Emerald
                'rgba(249, 115, 22, 0.7)',  // Orange
                'rgba(59, 130, 246, 0.7)',  // Blue
                'rgba(168, 85, 247, 0.7)',  // Violet
            ];
            
            const backgroundColors = labels.map((_, index) => colors[index % colors.length]);
            const borderColors = backgroundColors.map(color => color.replace('0.7', '1'));
            
            // Destroy existing chart
            if (productPieChart) {
                productPieChart.destroy();
            }
            
            // Create new pie chart
            const ctx = document.getElementById('productPieChart');
            if (!ctx) {
                console.error('Product pie chart canvas not found');
                return;
            }
            
            productPieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const clickedLabel = labels[index];
                            const productValue = clickedLabel === 'No Product' ? '' : clickedLabel;
                            
                            // Handle multi-selection with CTRL
                            if (event.event.ctrlKey || event.event.metaKey) {
                                // Toggle selection
                                if (selectedProducts.has(productValue)) {
                                    selectedProducts.delete(productValue);
                                } else {
                                    selectedProducts.add(productValue);
                                }
                            } else {
                                // Single selection - replace
                                selectedProducts.clear();
                                if (productValue) {
                                    selectedProducts.add(productValue);
                                }
                            }
                            
                            // Update filter and show posts
                            updateProductFilterFromSelection();
                            showFilteredPosts('product', Array.from(selectedProducts));
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary').trim() || '#fff',
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: `Distribution per Product (${filteredPosts.length} posts)`,
                            color: getComputedStyle(document.body).getPropertyValue('--accent-primary').trim() || '#00d4ff',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function toggleChartView() {
            chartView = chartView === 'bar' ? 'line' : 'bar';
            updateChart();
        }

        function filterBySentiment(sentiment, event) {
            // Handle multi-selection with CTRL
            if (event && (event.ctrlKey || event.metaKey)) {
                if (selectedSentiments.has(sentiment)) {
                    selectedSentiments.delete(sentiment);
                } else {
                    selectedSentiments.add(sentiment);
                }
            } else {
                // Single selection - replace
                selectedSentiments.clear();
                if (sentiment) {
                    selectedSentiments.add(sentiment);
                }
            }
            
            // Update filter and show posts
            updateSentimentFilterFromSelection();
            if (selectedSentiments.size > 0) {
                showFilteredPosts('sentiment', Array.from(selectedSentiments));
            } else {
                document.getElementById('sentimentFilter').value = '';
                currentOffset = 0;
                saveFilters();
                renderGallery();
            }
            console.log(`Filtering by sentiment: ${Array.from(selectedSentiments).join(', ') || 'All'}`);
        }
        
        function updateProductFilterFromSelection() {
            if (selectedProducts.size === 0) {
                document.getElementById('ovhProductFilter').value = '';
            } else if (selectedProducts.size === 1) {
                document.getElementById('ovhProductFilter').value = Array.from(selectedProducts)[0];
            } else {
                // Multiple products selected - we'll handle this in the filter logic
                document.getElementById('ovhProductFilter').value = '';
            }
            currentOffset = 0;
            saveFilters();
            renderGallery();
        }
        
        function updateSentimentFilterFromSelection() {
            if (selectedSentiments.size === 0) {
                document.getElementById('sentimentFilter').value = '';
            } else if (selectedSentiments.size === 1) {
                document.getElementById('sentimentFilter').value = Array.from(selectedSentiments)[0];
            } else {
                // Multiple sentiments selected - we'll handle this in the filter logic
                document.getElementById('sentimentFilter').value = '';
            }
        }
        
        function showFilteredPosts(filterType, filterValues) {
            let filtered = allPosts.filter(post => {
                // Filter out sample data
                const url = post.url || '';
                const isSample = (
                    url.includes('/sample') || 
                    url.includes('example.com') ||
                    url.includes('/status/174') ||
                    url === 'https://trustpilot.com/sample'
                );
                if (isSample) return false;
                
                if (filterType === 'product') {
                    const productLabel = getProductLabel(post.id, post.content, post.language);
                    const productValue = productLabel || '';
                    return filterValues.includes(productValue);
                } else if (filterType === 'sentiment') {
                    return filterValues.includes(post.sentiment_label);
                }
                return false;
            });
            
            // Update modal title and count
            const modal = document.getElementById('filteredPostsModal');
            const titleEl = document.getElementById('filteredPostsTitle');
            const countEl = document.getElementById('filteredPostsCount');
            const contentEl = document.getElementById('filteredPostsContent');
            
            if (filterType === 'product') {
                titleEl.textContent = `üìã Posts for: ${filterValues.join(', ') || 'No Product'}`;
            } else if (filterType === 'sentiment') {
                titleEl.textContent = `üìã Posts with sentiment: ${filterValues.join(', ')}`;
            }
            
            countEl.textContent = `${filtered.length} post${filtered.length !== 1 ? 's' : ''} found`;
            
            // Render posts
            contentEl.innerHTML = '';
            if (filtered.length === 0) {
                contentEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No posts found</p>';
            } else {
                filtered.forEach(post => {
                    const postDiv = document.createElement('div');
                    postDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; background: var(--bg-card); border-radius: 8px; border-left: 4px solid var(--accent-primary);';
                    
                    const sentimentColor = post.sentiment_label === 'positive' ? '#34d399' : 
                                          post.sentiment_label === 'negative' ? '#ef4444' : '#6b7280';
                    
                    postDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <strong style="color: var(--accent-primary);">${post.source.toUpperCase()}</strong>
                                <span style="margin-left: 10px; color: var(--text-secondary);">by ${post.author || 'Unknown'}</span>
                                <span style="margin-left: 10px; padding: 2px 8px; background: ${sentimentColor}; color: white; border-radius: 12px; font-size: 0.85em;">
                                    ${post.sentiment_label.toUpperCase()}
                                </span>
                            </div>
                            <span style="color: var(--text-muted); font-size: 0.9em;">${new Date(post.created_at).toLocaleDateString()}</span>
                        </div>
                        <p style="color: var(--text-primary); line-height: 1.6; margin-bottom: 10px;">${post.content}</p>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <a href="${post.url}" target="_blank" style="color: var(--accent-primary); text-decoration: none; font-size: 0.9em;">üîó View Original</a>
                            <button onclick="openPostPreview(${post.id})" style="padding: 4px 12px; background: var(--accent-primary); color: #1a1a2e; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em;">üëÅÔ∏è Preview</button>
                        </div>
                    `;
                    contentEl.appendChild(postDiv);
                });
            }
            
            modal.style.display = 'block';
        }
        
        function closeFilteredPostsModal() {
            document.getElementById('filteredPostsModal').style.display = 'none';
        }
        
        function applyFilteredPostsToGallery() {
            // Apply the current selection to the main gallery
            if (selectedProducts.size > 0) {
                updateProductFilterFromSelection();
            }
            if (selectedSentiments.size > 0) {
                updateSentimentFilterFromSelection();
                currentOffset = 0;
                saveFilters();
                renderGallery();
            }
            closeFilteredPostsModal();
            showToast('Filter applied to gallery', 'success');
        }

        // Abort controller for canceling requests
        let currentAbortController = null;

        function showCancelBtn(show) {
            const cancelBtn = document.getElementById('cancelBtn');
            if (cancelBtn) {
                cancelBtn.style.display = show ? 'inline-block' : 'none';
            }
        }

        function setButtonLoading(buttonId, loading) {
            const btn = document.getElementById(buttonId);
            if (!btn) return;
            const text = btn.querySelector('.btn-text');
            const spinner = btn.querySelector('.btn-spinner');
            if (loading) {
                btn.disabled = true;
                if (text) text.style.opacity = '0.7';
                if (spinner) spinner.style.display = 'inline-block';
            } else {
                btn.disabled = false;
                if (text) text.style.opacity = '1';
                if (spinner) spinner.style.display = 'none';
            }
        }

        async function cancelScrape() {
            if (currentAbortController) {
                currentAbortController.abort();
                console.log('Canceling scrape operation...');
            }
        }

        function updateActiveFiltersCount() {
            const searchTerm = document.getElementById('searchInput').value;
            const sourceFilter = document.getElementById('sourceFilter').value;
            const sentimentFilter = document.getElementById('sentimentFilter').value;
            const ovhProductFilter = document.getElementById('ovhProductFilter').value;
            const languageFilter = document.getElementById('languageFilter').value;
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;
            
            let count = 0;
            if (searchTerm) count++;
            if (sourceFilter) count++;
            if (sentimentFilter) count++;
            if (ovhProductFilter) count++;
            if (languageFilter) count++;
            if (dateFrom || dateTo) count++;
            
            const countEl = document.getElementById('activeFiltersCount');
            if (countEl) {
                if (count > 0) {
                    countEl.textContent = count;
                    countEl.style.display = 'inline-block';
                } else {
                    countEl.style.display = 'none';
                }
            }
        }

        function applySorting() {
            const sortBy = document.getElementById('sortBy').value;
            currentOffset = 0;
            renderGallery();
        }

        function exportFilteredResults() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const sourceFilter = document.getElementById('sourceFilter').value;
            const sentimentFilter = document.getElementById('sentimentFilter').value;
            const ovhProductFilter = document.getElementById('ovhProductFilter').value;
            const languageFilter = document.getElementById('languageFilter').value;
            const dateFrom = document.getElementById('dateFrom').value;
            const dateTo = document.getElementById('dateTo').value;
            const keywordFilter = document.getElementById('keywordFilter') ? document.getElementById('keywordFilter').value : '';

            const keywordPatterns = {
                // Add keyword patterns if needed
            };

            const ovhProductPatterns = {
                // Web & Hosting
                'web-hosting': /\b(web\s*host|hosting|h√©bergement|mutualis√©|shared\s*host)\w*/i,
                'wordpress': /\b(wordpress|wp\s*host)\w*/i,
                'email': /\b(email|exchange|mail|mx|zimbra)\w*/i,
                'domain': /\b(domain|domaine|dns|zone|registrar)\w*/i,
                
                // Cloud & Servers
                'vps': /\b(vps|virtual\s*private\s*server)\w*/i,
                'dedicated': /\b(dedicated|d√©di√©|bare\s*metal)\w*/i,
                'public-cloud': /\b(public\s*cloud|openstack|instance)\w*/i,
                'private-cloud': /\b(private\s*cloud|vmware)\w*/i,
                'hosted-private-cloud': /\b(hosted\s*private\s*cloud|hpc)\w*/i,
                
                // Storage & Backup
                'object-storage': /\b(object\s*storage|swift|s3)\w*/i,
                'cloud-archive': /\b(cloud\s*archive|archive)\w*/i,
                'nas-ha': /\b(nas|nas-ha)\w*/i,
                'veeam': /\b(veeam|backup)\w*/i,
                
                // Network & CDN
                'cdn': /\b(cdn|content\s*delivery)\w*/i,
                'load-balancer': /\b(load\s*balancer|iplb)\w*/i,
                'ddos': /\b(ddos|anti-ddos|protection)\w*/i,
                'vrack': /\b(vrack|private\s*network)\w*/i,
                
                // Telecom
                'voip': /\b(voip|telephony|t√©l√©phonie|sip)\w*/i,
                'sms': /\b(sms|text\s*message)\w*/i,
                'fax': /\b(fax|fax2mail)\w*/i,
                
                // Support & Billing
                'support': /\b(support|ticket|assistance|help)\w*/i,
                'billing': /\b(billing|facture|invoice|payment|paiement|refund|rembours)\w*/i,
                'manager': /\b(manager|control\s*panel|espace\s*client)\w*/i,
                'api': /\b(api|sdk|integration)\w*/i,
            };

            let filtered = allPosts.filter(post => {
                // Filter out sample data first
                const isSample = post.url && (
                    post.url.includes('/sample') || 
                    post.url.includes('example.com') ||
                    post.url.includes('/status/174') ||
                    post.url === 'https://trustpilot.com/sample'
                );
                if (isSample) {
                    return false;
                }
                
                const postContent = post.content.toLowerCase();
                const postUrl = (post.url || '').toLowerCase();
                const postAuthor = (post.author || '').toLowerCase();
                
                // Improved search: check content, author, AND url
                const matchesSearch = !searchTerm || 
                    postContent.includes(searchTerm) || 
                    postAuthor.includes(searchTerm) ||
                    postUrl.includes(searchTerm);
                const matchesSource = !sourceFilter || post.source === sourceFilter;
                const matchesSentiment = !sentimentFilter || post.sentiment_label === sentimentFilter;
                const matchesLanguage = !languageFilter || post.language === languageFilter;
                
                let matchesKeyword = true;
                if (keywordFilter && keywordPatterns[keywordFilter]) {
                    matchesKeyword = keywordPatterns[keywordFilter].test(post.content);
                }
                
                let matchesProduct = true;
                if (ovhProductFilter && ovhProductFilter !== 'all') {
                    const productLabel = getProductLabel(post.id, post.content, post.language);
                    matchesProduct = productLabel === ovhProductFilter;
                }
                
                let matchesDate = true;
                if (dateFrom || dateTo) {
                    const postDate = new Date(post.created_at).toISOString().split('T')[0];
                    if (dateFrom && postDate < dateFrom) matchesDate = false;
                    if (dateTo && postDate > dateTo) matchesDate = false;
                }
                
                return matchesSearch && matchesSource && matchesSentiment && matchesProduct && matchesDate && matchesLanguage && matchesKeyword;
            });

            // Apply sorting
            const sortBy = document.getElementById('sortBy').value;
            if (sortBy === 'date-desc') {
                filtered.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            } else if (sortBy === 'date-asc') {
                filtered.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            } else if (sortBy === 'sentiment-desc') {
                filtered.sort((a, b) => a.sentiment_score - b.sentiment_score);
            } else if (sortBy === 'sentiment-asc') {
                filtered.sort((a, b) => b.sentiment_score - a.sentiment_score);
            } else if (sortBy === 'source-asc') {
                filtered.sort((a, b) => a.source.localeCompare(b.source));
            } else if (sortBy === 'source-desc') {
                filtered.sort((a, b) => b.source.localeCompare(a.source));
            }

            if (filtered.length === 0) {
                showToast('No posts to export', 'error');
                return;
            }

            const csv = [
                ['ID', 'Source', 'Author', 'Content', 'URL', 'Date', 'Sentiment', 'Score', 'Language'],
                ...filtered.map(p => [
                    p.id,
                    p.source,
                    p.author,
                    p.content.replace(/"/g, '""'),
                    p.url,
                    p.created_at,
                    p.sentiment_label,
                    p.sentiment_score,
                    p.language || 'unknown'
                ])
            ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ovh-filtered-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            showToast(`Exported ${filtered.length} posts`, 'success');
        }


        async function scrapeX() {
            setButtonLoading('btnScrapeX', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            console.log('Starting X/Twitter scraper...', keywords);
            
            try {
                const response = await fetch(`${API_BASE}/scrape/x?query=${encodeURIComponent(combinedQuery)}&limit=50`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    console.log(`Successfully scraped ${data.added} posts from X/Twitter`);
                    showToast(`${data.added} new posts from X/Twitter`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    console.error(`Error scraping X: ${e.message}`);
                    showToast(`Error scraping X: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeX', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeStackOverflow() {
            setButtonLoading('btnScrapeStackOverflow', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            console.log('Starting Stack Overflow scraper...', keywords);
            
            try {
                const response = await fetch(`${API_BASE}/scrape/stackoverflow?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    console.log(`Successfully scraped ${data.added} questions from Stack Overflow`);
                    showToast(`${data.added} new posts from Stack Overflow`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    console.error(`Error scraping Stack Overflow: ${e.message}`);
                    showToast(`Error scraping Stack Overflow: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeStackOverflow', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeNews() {
            setButtonLoading('btnScrapeNews', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            console.log('Starting Google News scraper...');
            addLog(`üì∞ Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/news?query=${encodeURIComponent(combinedQuery)}&limit=50`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} articles from Google News`, 'success');
                    showToast(`${data.added} new posts from Google News`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    addLog(`‚ùå Error scraping News: ${e.message}`, 'error');
                    showToast(`Error scraping News: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeNews', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeReddit() {
            setButtonLoading('btnScrapeReddit', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Reddit scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/reddit?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} posts from Reddit`, 'success');
                    showToast(`${data.added} new posts from Reddit`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    addLog(`‚ùå Error scraping Reddit: ${e.message}`, 'error');
                    showToast(`Error scraping Reddit: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeReddit', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeGithub() {
            setButtonLoading('btnScrapeGithub', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting GitHub Issues scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/github?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} issues/discussions from GitHub`, 'success');
                    showToast(`${data.added} new posts from GitHub`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    addLog(`‚ùå Error scraping GitHub: ${e.message}`, 'error');
                    showToast(`Error scraping GitHub: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeGithub', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }


        async function scrapeTrustpilot() {
            setButtonLoading('btnScrapeTrustpilot', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            // Combine keywords with AND
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Trustpilot scraper...', 'info');
            addLog(`‚≠ê Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/trustpilot?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} reviews from Trustpilot`, 'success');
                    showToast(`${data.added} new posts from Trustpilot`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    console.error(`Error: ${data.detail}`);
                    showToast(`Error: ${data.detail}`, 'error');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Scrape cancelled by user');
                } else {
                    addLog(`‚ùå Error scraping Trustpilot: ${e.message}`, 'error');
                    showToast(`Error scraping Trustpilot: ${e.message}`, 'error');
                }
            } finally {
                setButtonLoading('btnScrapeTrustpilot', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeAllSources() {
            setButtonLoading('btnScrapeAll', true);
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            // Capture the abort controller locally to avoid null reference errors in async functions
            const localAbortController = currentAbortController;
            
            // Clear previous logs and show log panel (like individual scrapers do)
            console.log('Starting data collection - launching all scrapers...');
            showToast('Collecting new data from all sources...', 'info');
            
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                addLog('‚ö†Ô∏è No keywords configured. Add keywords first!', 'error');
                showToast('Please add keywords before scraping', 'error');
                setButtonLoading('btnScrapeAll', false);
                showCancelBtn(false);
                currentAbortController = null;
                return;
            }
            
            let totalAdded = 0;
            let completedScrapers = 0;
            const totalScrapers = 10; // X, StackOverflow, News, Reddit, Trustpilot, GitHub, OVH Forum, Mastodon, G2 Crowd, LinkedIn
            
            try {
                // Run all scrapers in parallel
                const scraperPromises = [];
                
                // 1. X/Twitter Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Scraping X/Twitter...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/x`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                }
                            }
                            completedScrapers++;
                            console.log(`X/Twitter scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`X/Twitter scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 2. StackOverflow Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Starting Stack Overflow scraper...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/stackoverflow`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    console.log(`Successfully scraped ${result.added} questions from Stack Overflow (keyword: ${keyword})`);
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    console.error(`Error scraping Stack Overflow (keyword: ${keyword}): ${errorData.detail}`);
                                }
                            }
                            completedScrapers++;
                            console.log(`StackOverflow scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`StackOverflow scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 3. News Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Starting Google News scraper...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/news`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    console.log(`Successfully scraped ${result.added} articles from Google News (keyword: ${keyword})`);
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    console.error(`Error scraping Google News (keyword: ${keyword}): ${errorData.detail}`);
                                }
                            }
                            completedScrapers++;
                            console.log(`Google News scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`Google News scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 4. Reddit Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Starting Reddit scraper...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/reddit`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    console.log(`Successfully scraped ${result.added} posts from Reddit (keyword: ${keyword})`);
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    console.error(`Error scraping Reddit (keyword: ${keyword}): ${errorData.detail}`);
                                }
                            }
                            completedScrapers++;
                            console.log(`Reddit scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`Reddit scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 5. Trustpilot Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Starting Trustpilot scraper...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/trustpilot`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 20 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    console.log(`Successfully scraped ${result.added} reviews from Trustpilot (keyword: ${keyword})`);
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    console.error(`Error scraping Trustpilot (keyword: ${keyword}): ${errorData.detail}`);
                                }
                            }
                            completedScrapers++;
                            console.log(`Trustpilot scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`Trustpilot scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 6. GitHub Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            console.log('Starting GitHub scraper...');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/github`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    console.log(`Successfully scraped ${result.added} issues from GitHub (keyword: ${keyword})`);
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    console.error(`Error scraping GitHub (keyword: ${keyword}): ${errorData.detail}`);
                                }
                            }
                            completedScrapers++;
                            console.log(`GitHub scraping complete (${completedScrapers}/${totalScrapers})`);
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.error(`GitHub scraping failed: ${e.message}`);
                            }
                        }
                    })()
                );
                
                // 7. OVH Forum Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            addLog('üîÑ Starting OVH Forum scraper...', 'info');
                            addLog(`üí¨ Searching for: ${keywords.join(', ')}`, 'info');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/ovh-forum`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    addLog(`‚úÖ Successfully scraped ${result.added} posts from OVH Forum (keyword: ${keyword})`, 'success');
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    addLog(`‚ùå Error scraping OVH Forum (keyword: ${keyword}): ${errorData.detail}`, 'error');
                                }
                            }
                            completedScrapers++;
                            addLog(`‚úÖ OVH Forum scraping complete (${completedScrapers}/${totalScrapers})`, 'success');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                addLog(`‚ùå OVH Forum scraping failed: ${e.message}`, 'error');
                            }
                        }
                    })()
                );
                
                // 8. Mastodon Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            addLog('üîÑ Starting Mastodon scraper...', 'info');
                            addLog(`üêò Searching for: ${keywords.join(', ')}`, 'info');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/mastodon`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    addLog(`‚úÖ Successfully scraped ${result.added} posts from Mastodon (keyword: ${keyword})`, 'success');
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    addLog(`‚ùå Error scraping Mastodon (keyword: ${keyword}): ${errorData.detail}`, 'error');
                                }
                            }
                            completedScrapers++;
                            addLog(`‚úÖ Mastodon scraping complete (${completedScrapers}/${totalScrapers})`, 'success');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                addLog(`‚ùå Mastodon scraping failed: ${e.message}`, 'error');
                            }
                        }
                    })()
                );
                
                // 9. G2 Crowd Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            addLog('üîÑ Starting G2 Crowd scraper...', 'info');
                            addLog(`‚≠ê Searching for: ${keywords.join(', ')}`, 'info');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/g2-crowd`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    addLog(`‚úÖ Successfully scraped ${result.added} reviews from G2 Crowd (keyword: ${keyword})`, 'success');
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    addLog(`‚ùå Error scraping G2 Crowd (keyword: ${keyword}): ${errorData.detail}`, 'error');
                                }
                            }
                            completedScrapers++;
                            addLog(`‚úÖ G2 Crowd scraping complete (${completedScrapers}/${totalScrapers})`, 'success');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                addLog(`‚ùå G2 Crowd scraping failed: ${e.message}`, 'error');
                            }
                        }
                    })()
                );
                
                // 10. LinkedIn Scraper
                scraperPromises.push(
                    (async () => {
                        try {
                            addLog('üîÑ Starting LinkedIn scraper...', 'info');
                            addLog(`üíº Searching for: ${keywords.join(', ')}`, 'info');
                            addLog('üí° Note: LinkedIn requires API credentials (Client ID & Secret) configured in Settings', 'info');
                            for (const keyword of keywords) {
                                const response = await fetch(`${API_BASE}/scrape/linkedin`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ query: keyword, limit: 50 }),
                                    signal: localAbortController.signal
                                });
                                if (response.ok) {
                                    const result = await response.json();
                                    totalAdded += result.added || 0;
                                    if (result.added > 0) {
                                        addLog(`‚úÖ Successfully scraped ${result.added} posts from LinkedIn (keyword: ${keyword})`, 'success');
                                    } else {
                                        addLog(`‚ö†Ô∏è No posts found from LinkedIn (keyword: ${keyword}) - Check API credentials in Settings`, 'warning');
                                    }
                                } else {
                                    const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                                    addLog(`‚ùå Error scraping LinkedIn (keyword: ${keyword}): ${errorData.detail}`, 'error');
                                }
                            }
                            completedScrapers++;
                            addLog(`‚úÖ LinkedIn scraping complete (${completedScrapers}/${totalScrapers})`, 'success');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                addLog(`‚ùå LinkedIn scraping failed: ${e.message}`, 'error');
                            }
                        }
                    })()
                );
                
                // Wait for all scrapers to complete
                await Promise.all(scraperPromises);
                
                // Now load the updated data from database
                addLog('üì• Loading updated data from database...', 'info');
                const response = await fetch(`${API_BASE}/posts?limit=1000`, {
                    signal: localAbortController.signal
                });
                
                if (response.ok) {
                    const posts = await response.json();
                    // Filter out sample posts
                    allPosts = posts.filter(post => {
                        const url = post.url || '';
                        const isSample = (
                            url.includes('/sample') || 
                            url.includes('example.com') ||
                            url.includes('/status/174') ||
                            url === 'https://trustpilot.com/sample'
                        );
                        return !isSample;
                    });
                    const filteredCount = posts.length - allPosts.length;
                    addLog(`‚úÖ Full refresh complete! Added ${totalAdded} new posts. Total: ${allPosts.length} posts${filteredCount > 0 ? ` (${filteredCount} samples filtered)` : ''}`, 'success');
                    showToast(`Refresh complete! ${totalAdded} new posts added`, 'success');
                    
                    // Render gallery with updated data
                    renderGallery();
                    updateActiveFiltersCount();
                } else {
                    addLog('‚ùå Failed to load updated data', 'error');
                    showToast('Failed to load updated data', 'error');
                    // Still render gallery to keep existing posts visible
                    renderGallery();
                }
                
            } catch (e) {
                if (e.name === 'AbortError') {
                    addLog('‚õî Refresh cancelled by user', 'error');
                    showToast('Refresh cancelled', 'error');
                } else {
                    addLog(`‚ùå Refresh error: ${e.message}`, 'error');
                    showToast(`Error: ${e.message}`, 'error');
                }
                // Keep existing posts visible even if there's an error
                renderGallery();
            } finally {
                setButtonLoading('btnScrapeAll', false);
                showCancelBtn(false);
                currentAbortController = null;
                updateActiveFiltersCount();
            }
        }

        async function scrapeOvhForum() {
            setButtonLoading('btnScrapeOvhForum', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting OVH Forum scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/ovh-forum?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} posts from OVH Forum`, 'success');
                    showToast(`${data.added} new posts from OVH Forum`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    addLog(`‚ùå Error scraping OVH Forum: ${data.detail || 'Unknown error'}`, 'error');
                    showToast('Error scraping OVH Forum', 'error');
                }
            } catch (e) {
                if (e.name !== 'AbortError') {
                    addLog(`‚ùå Error scraping OVH Forum: ${e.message}`, 'error');
                    showToast('Error scraping OVH Forum', 'error');
                }
            } finally {
                setButtonLoading('btnScrapeOvhForum', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeMastodon() {
            setButtonLoading('btnScrapeMastodon', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting Mastodon scraper...', 'info');
            addLog(`üîç Searching for (AND): ${keywords.join(' + ')}`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/scrape/mastodon?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                const data = await response.json();
                if (response.ok) {
                    addLog(`‚úÖ Successfully scraped ${data.added} posts from Mastodon`, 'success');
                    showToast(`${data.added} new posts from Mastodon`, 'success');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    addLog(`‚ùå Error scraping Mastodon: ${data.detail || 'Unknown error'}`, 'error');
                    showToast('Error scraping Mastodon', 'error');
                }
            } catch (e) {
                if (e.name !== 'AbortError') {
                    addLog(`‚ùå Error scraping Mastodon: ${e.message}`, 'error');
                    showToast('Error scraping Mastodon', 'error');
                }
            } finally {
                setButtonLoading('btnScrapeMastodon', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeG2Crowd() {
            setButtonLoading('btnScrapeG2', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting G2 Crowd scraper...', 'info');
            addLog(`üîç Query: "${combinedQuery}"`, 'info');
            addLog(`üìä Limit: 100 reviews`, 'info');
            addLog(`üåê Target URL: https://www.g2.com/products/ovhcloud/reviews`, 'info');
            addLog('‚è≥ Fetching page...', 'info');
            
            const startTime = Date.now();
            
            try {
                const response = await fetch(`${API_BASE}/scrape/g2-crowd?query=${encodeURIComponent(combinedQuery)}&limit=100`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                addLog(`‚è±Ô∏è Request completed in ${elapsed}s`, 'info');
                addLog(`üì° Response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                
                const data = await response.json();
                
                if (response.ok) {
                    addLog(`üì¶ Items returned by scraper: ${data.added}`, data.added > 0 ? 'success' : 'warning');
                    
                    if (data.added === 0) {
                        addLog('‚ö†Ô∏è No posts found. Possible reasons:', 'warning');
                        addLog('   ‚Ä¢ G2 Crowd may be blocking the scraper (403 Forbidden)', 'info');
                        addLog('   ‚Ä¢ The page structure may have changed', 'info');
                        addLog('   ‚Ä¢ No reviews match the search criteria', 'info');
                        addLog('   ‚Ä¢ Check backend logs for detailed error messages', 'info');
                    } else {
                        addLog(`‚úÖ Successfully scraped ${data.added} reviews from G2 Crowd`, 'success');
                    }
                    
                    showToast(`${data.added} new posts from G2 Crowd`, data.added > 0 ? 'success' : 'warning');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    addLog(`‚ùå API Error: ${data.detail || 'Unknown error'}`, 'error');
                    addLog(`üìã Error details: ${JSON.stringify(data, null, 2)}`, 'error');
                    showToast('Error scraping G2 Crowd', 'error');
                }
            } catch (e) {
                if (e.name !== 'AbortError') {
                    addLog(`‚ùå Network/Request Error: ${e.message}`, 'error');
                    addLog(`üìã Error type: ${e.name}`, 'error');
                    if (e.stack) {
                        addLog(`üìã Stack trace: ${e.stack.substring(0, 200)}...`, 'error');
                    }
                    showToast('Error scraping G2 Crowd', 'error');
                } else {
                    addLog('‚õî Scraping cancelled by user', 'info');
                }
            } finally {
                const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
                addLog(`‚è±Ô∏è Total time: ${totalTime}s`, 'info');
                setButtonLoading('btnScrapeG2', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        async function scrapeLinkedIn() {
            setButtonLoading('btnScrapeLinkedIn', true);
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                console.log('No keywords configured - using defaults');
                keywords = ['ovhcloud', 'ovh cloud', 'ovh hosting'];
            }
            
            const combinedQuery = keywords.join(' ');
            
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            showCancelBtn(true);
            currentAbortController = new AbortController();
            
            addLog('üîÑ Starting LinkedIn scraper...', 'info');
            addLog(`üîç Query: "${combinedQuery}"`, 'info');
            addLog(`üìä Limit: 50 posts`, 'info');
            addLog('üí° Note: LinkedIn requires API credentials (Client ID & Secret) configured in Settings', 'info');
            addLog('‚è≥ Fetching posts...', 'info');
            
            const startTime = Date.now();
            
            try {
                const response = await fetch(`${API_BASE}/scrape/linkedin?query=${encodeURIComponent(combinedQuery)}&limit=50`, {
                    method: 'POST',
                    signal: currentAbortController.signal
                });
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                addLog(`‚è±Ô∏è Request completed in ${elapsed}s`, 'info');
                addLog(`üì° Response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                
                const data = await response.json();
                
                if (response.ok) {
                    addLog(`üì¶ Items returned by scraper: ${data.added}`, data.added > 0 ? 'success' : 'warning');
                    
                    if (data.added === 0) {
                        addLog('‚ö†Ô∏è No posts found. Possible reasons:', 'warning');
                        addLog('   ‚Ä¢ LinkedIn API credentials not configured (check Settings)', 'info');
                        addLog('   ‚Ä¢ LinkedIn API v2 has limited search capabilities', 'info');
                        addLog('   ‚Ä¢ No posts match the search criteria', 'info');
                        addLog('   ‚Ä¢ Check backend logs for detailed error messages', 'info');
                        addLog('   ‚Ä¢ See docs/guides/LINKEDIN_API_SETUP.md for setup instructions', 'info');
                    } else {
                        addLog(`‚úÖ Successfully scraped ${data.added} posts from LinkedIn`, 'success');
                    }
                    
                    showToast(`${data.added} new posts from LinkedIn`, data.added > 0 ? 'success' : 'warning');
                    await loadPostsFromDB();
                    renderGallery();
                } else {
                    addLog(`‚ùå API Error: ${data.detail || 'Unknown error'}`, 'error');
                    addLog(`üìã Error details: ${JSON.stringify(data, null, 2)}`, 'error');
                    showToast('Error scraping LinkedIn', 'error');
                }
            } catch (e) {
                if (e.name !== 'AbortError') {
                    addLog(`‚ùå Network/Request Error: ${e.message}`, 'error');
                    addLog(`üìã Error type: ${e.name}`, 'error');
                    if (e.stack) {
                        addLog(`üìã Stack trace: ${e.stack.substring(0, 200)}...`, 'error');
                    }
                    showToast('Error scraping LinkedIn', 'error');
                } else {
                    addLog('‚õî Scraping cancelled by user', 'info');
                }
            } finally {
                const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
                addLog(`‚è±Ô∏è Total time: ${totalTime}s`, 'info');
                setButtonLoading('btnScrapeLinkedIn', false);
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        // Backlog functions
        function loadBacklog() {
            const saved = localStorage.getItem('ovh_backlog');
            return saved ? JSON.parse(saved) : [];
        }

        function saveBacklog(backlog) {
            localStorage.setItem('ovh_backlog', JSON.stringify(backlog));
        }

        function addToBacklog(postId) {
            const post = allPosts.find(p => p.id === postId);
            if (!post) return;

            const backlog = loadBacklog();
            if (!backlog.find(p => p.id === postId)) {
                backlog.push(post);
                saveBacklog(backlog);
                const preview = post.content.substring(0, 45) + (post.content.length > 45 ? '...' : '');
                showToast(`Saved: "${preview}"`, 'success');
            } else {
                showToast('This post is already in the backlog', 'error');
            }
        }

        function toggleBacklog() {
            const sidebar = document.getElementById('backlogSidebar');
            const backdrop = document.getElementById('backlogBackdrop');
            
            if (sidebar.style.right === '0px' || sidebar.style.right === '') {
                // Close sidebar
                sidebar.style.right = '-450px';
                backdrop.style.display = 'none';
            } else {
                // Open sidebar
                sidebar.style.right = '0px';
                backdrop.style.display = 'block';
                renderBacklog();
            }
        }

        // Comment management functions
        function loadComments() {
            const saved = localStorage.getItem('ovh_backlog_comments');
            return saved ? JSON.parse(saved) : {};
        }
        
        function saveComments(comments) {
            localStorage.setItem('ovh_backlog_comments', JSON.stringify(comments));
        }
        
        function getComment(postId) {
            const comments = loadComments();
            return comments[postId] || '';
        }
        
        function saveComment(postId, comment) {
            const comments = loadComments();
            comments[postId] = comment;
            saveComments(comments);
            // Optional: show a subtle feedback
            const textarea = document.getElementById(`comment-${postId}`);
            if (textarea) {
                const originalBg = textarea.style.background;
                textarea.style.background = 'rgba(52, 211, 153, 0.2)';
                setTimeout(() => {
                    textarea.style.background = originalBg;
                }, 300);
            }
        }
        
        function toggleBacklogView() {
            backlogView = backlogView === 'card' ? 'list' : 'card';
            const toggleBtn = document.getElementById('backlogViewToggle');
            if (toggleBtn) {
                toggleBtn.textContent = backlogView === 'card' ? 'üìã Card View' : 'üìÑ List View';
            }
            localStorage.setItem('ovh_backlog_view', backlogView);
            renderBacklog();
        }
        
        function renderBacklog() {
            const backlog = loadBacklog();
            const backlogGallery = document.getElementById('backlogGallery');
            
            // Load saved view preference
            const savedView = localStorage.getItem('ovh_backlog_view');
            if (savedView) backlogView = savedView;
            const toggleBtn = document.getElementById('backlogViewToggle');
            if (toggleBtn) {
                toggleBtn.textContent = backlogView === 'card' ? 'üìã Card View' : 'üìÑ List View';
            }

            if (backlog.length === 0) {
                backlogGallery.innerHTML = '<div class="empty-state"><p style="color: var(--text-secondary);">No posts in backlog yet. Click "Save" on any post to add it here.</p></div>';
                return;
            }

            if (backlogView === 'list') {
                // Compact list view
                backlogGallery.innerHTML = backlog.map(post => {
                    const productLabel = getProductLabel(post.id, post.content, post.language);
                    const comment = getComment(post.id);
                    const hasComment = comment && comment.trim().length > 0;
                    
                    return `
                    <div style="padding: 12px; margin-bottom: 10px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px; border-left: 3px solid var(--accent-primary);">
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px; margin-bottom: 8px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px; flex-wrap: wrap;">
                                    <span class="${getSourceClass(post.source)}" style="font-size: 0.75em;">${escapeHtml(post.source)}</span>
                                    <span class="post-date" style="font-size: 0.75em;">${formatDate(post.created_at)}</span>
                                    ${productLabel ? `<span style="font-size:0.7em; background:rgba(0,212,255,0.2); padding:2px 6px; border-radius:3px;">${escapeHtml(productLabel)}</span>` : ''}
                                    <span class="${getSentimentClass(post.sentiment_label)}" style="font-size: 0.75em;">${post.sentiment_label.toUpperCase()}</span>
                                </div>
                                <div style="color: var(--text-primary); font-size: 0.9em; margin-bottom: 5px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                                    ${escapeHtml(post.content.substring(0, 200))}${post.content.length > 200 ? '...' : ''}
                                </div>
                                ${hasComment ? `<div style="font-size: 0.8em; color: var(--text-secondary); font-style: italic; margin-top: 5px;">üí¨ ${escapeHtml(comment.substring(0, 100))}${comment.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 5px; flex-shrink: 0;">
                                <button onclick="openPostPreview(${post.id})" style="padding: 4px 8px; background: #34d399; border: none; border-radius: 4px; color: #1a1a2e; cursor: pointer; font-size: 0.75em;">üëÅÔ∏è</button>
                                <button onclick="removeFromBacklog(${post.id})" style="padding: 4px 8px; background: #ef4444; border: none; border-radius: 4px; color: #fff; cursor: pointer; font-size: 0.75em;">√ó</button>
                            </div>
                        </div>
                    </div>
                    `;
                }).join('');
            } else {
                // Card view (existing)
                backlogGallery.innerHTML = backlog.map(post => {
                    const productLabel = getProductLabel(post.id, post.content, post.language);
                    const comment = getComment(post.id);
                    
                    return `
                    <div class="post-card" style="margin-bottom: 20px;">
                        <div class="post-header">
                            <span class="${getSourceClass(post.source)}">${escapeHtml(post.source)}</span>
                            <span class="post-date">${formatDate(post.created_at)}</span>
                            ${productLabel ? `
                                <span style="font-size:0.75em; background:rgba(0,212,255,0.2); padding:4px 8px; border-radius:4px; margin-left:5px; display:inline-flex; align-items:center; gap:4px;">
                                    ${escapeHtml(productLabel)}
                                    <button onclick="editProductLabel(${post.id}, '${escapeHtml(productLabel).replace(/'/g, "\\'")}')" 
                                            style="background:none; border:none; color:var(--accent-primary); cursor:pointer; padding:0; margin:0; font-size:0.9em; opacity:0.7;"
                                            title="Edit product label">‚úèÔ∏è</button>
                                </span>
                            ` : `
                                <button onclick="editProductLabel(${post.id}, '')" 
                                        style="font-size:0.75em; background:rgba(0,212,255,0.1); padding:4px 8px; border-radius:4px; margin-left:5px; border:1px dashed rgba(0,212,255,0.3); color:var(--accent-primary); cursor:pointer;"
                                        title="Add product label">+ Label</button>
                            `}
                        </div>
                        <div class="post-author">@${escapeHtml(post.author)}</div>
                        <div class="post-content" style="max-height: 150px; overflow-y: auto;">${escapeHtml(post.content)}</div>
                        <div class="post-footer">
                            <span class="${getSentimentClass(post.sentiment_label)}">
                                ${post.sentiment_label.toUpperCase()} (${(post.sentiment_score).toFixed(2)})
                            </span>
                            <button onclick="openPostPreview(${post.id})" style="margin-left:10px; padding:6px 12px; background:#34d399; border:none; border-radius:6px; color:#1a1a2e; cursor:pointer; font-weight:500; font-size:0.85em;">üëÅÔ∏è Preview</button>
                            <a href="${escapeHtml(post.url)}" target="_blank" class="post-url" style="margin-left:10px; font-size:0.85em;">View</a>
                            <button onclick="removeFromBacklog(${post.id})" style="margin-left:10px; padding:6px 12px; background:#ef4444; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:0.85em;">Remove</button>
                        </div>
                        <!-- Comment Section -->
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                            <label style="display: block; color: var(--text-secondary); font-size: 0.9em; margin-bottom: 8px; font-weight: bold;">üí¨ Notes/Comments:</label>
                            <textarea 
                                id="comment-${post.id}" 
                                onchange="saveComment(${post.id}, this.value)"
                                placeholder="Add your notes or comments about this post..."
                                style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-primary); font-family: inherit; font-size: 0.9em; resize: vertical;"
                            >${escapeHtml(comment)}</textarea>
                        </div>
                    </div>
                    `;
                }).join('');
            }
        }

        function removeFromBacklog(postId) {
            let backlog = loadBacklog();
            backlog = backlog.filter(p => p.id !== postId);
            saveBacklog(backlog);
            renderBacklog();
            console.log(`Post ${postId} removed from backlog`);
        }

        function clearBacklog() {
            if (confirm('Are you sure you want to clear the entire backlog?')) {
                localStorage.removeItem('ovh_backlog');
                renderBacklog();
                console.log('Backlog cleared');
            }
        }

        function exportBacklog() {
            const backlog = loadBacklog();
            if (backlog.length === 0) {
                alert('Backlog is empty');
                return;
            }

            const comments = loadComments();
            const csv = [
                ['ID', 'Source', 'Author', 'Content', 'URL', 'Date', 'Sentiment', 'Score', 'Comment'],
                ...backlog.map(p => [
                    p.id,
                    p.source,
                    p.author,
                    p.content.replace(/"/g, '""'),
                    p.url,
                    p.created_at,
                    p.sentiment_label,
                    p.sentiment_score,
                    (comments[p.id] || '').replace(/"/g, '""')
                ])
            ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ovh-backlog-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        async function generateImprovementIdeas() {
            const backlog = loadBacklog();
            if (backlog.length === 0) {
                showToast('Backlog is empty. Add some posts first to generate ideas.', 'error');
                return;
            }
            
            // Show loading state
            const generateBtn = document.querySelector('button[onclick="generateImprovementIdeas()"]');
            const originalText = generateBtn ? generateBtn.textContent : 'üí° Generate Ideas';
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.textContent = '‚è≥ Analyzing...';
            }
            
            try {
                // Call backend API to generate ideas with LLM
                const response = await fetch(`${API_BASE}/generate-improvement-ideas`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        posts: backlog,
                        max_ideas: 5
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }
                
                const data = await response.json();
                const ideas = data.ideas || [];
                
                if (ideas.length === 0) {
                    showToast('No ideas generated. Try adding more posts to backlog.', 'error');
                    return;
                }
                
                // Display ideas in modal for validation
                displayIdeasForValidation(ideas);
                
            } catch (error) {
                console.error('Error generating ideas:', error);
                showToast('Error generating ideas. Please check if the backend is running and LLM API is configured.', 'error');
            } finally {
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = originalText;
                }
            }
        }
        
        function displayIdeasForValidation(ideas) {
            const modal = document.getElementById('ideasModal');
            const contentDiv = document.getElementById('ideasContent');
            
            if (!modal || !contentDiv) return;
            
            contentDiv.innerHTML = ideas.map((idea, index) => {
                const priorityColor = {
                    'high': '#ef4444',
                    'medium': '#f59e0b',
                    'low': '#6b7280'
                }[idea.priority] || '#6b7280';
                
                return `
                    <div style="margin-bottom: 20px; padding: 20px; background: var(--bg-card); border-radius: 8px; border-left: 4px solid ${priorityColor};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                            <div style="flex: 1;">
                                <h3 style="color: var(--accent-primary); margin: 0 0 10px 0; font-size: 1.2em;">${escapeHtml(idea.title)}</h3>
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                    <span style="padding: 4px 10px; background: ${priorityColor}20; color: ${priorityColor}; border-radius: 4px; font-size: 0.85em; font-weight: bold;">
                                        ${idea.priority.toUpperCase()} Priority
                                    </span>
                                    <span style="color: var(--text-secondary); font-size: 0.85em;">
                                        üìä Based on ${idea.related_posts_count} post(s)
                                    </span>
                                </div>
                            </div>
                        </div>
                        <p style="color: var(--text-primary); line-height: 1.6; margin-bottom: 15px; white-space: pre-wrap;">${escapeHtml(idea.description)}</p>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="acceptIdea(${index})" style="padding: 10px 20px; background: #10b981; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-weight: bold; flex: 1;">
                                ‚úÖ Add to Backlog
                            </button>
                            <button onclick="rejectIdea(${index})" style="padding: 10px 20px; background: #6b7280; border: none; border-radius: 6px; color: #fff; cursor: pointer; flex: 1;">
                                ‚ùå Reject
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Store ideas temporarily for validation
            window.pendingIdeas = ideas;
            modal.style.display = 'block';
        }
        
        function acceptIdea(index) {
            const idea = window.pendingIdeas[index];
            if (!idea) return;
            
            // Convert idea to post format and add to backlog
            const ideaPost = {
                id: `idea-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                source: 'üí° AI Generated Idea',
                author: 'System',
                content: `${idea.title}\n\n${idea.description}\n\nPriority: ${idea.priority}\nBased on: ${idea.related_posts_count} post(s)`,
                url: '',
                created_at: new Date().toISOString(),
                sentiment_label: 'neutral',
                sentiment_score: 0.0,
                language: 'en'
            };
            
            const backlog = loadBacklog();
            backlog.push(ideaPost);
            saveBacklog(backlog);
            renderBacklog();
            
            // Remove accepted idea from modal
            window.pendingIdeas.splice(index, 1);
            if (window.pendingIdeas.length === 0) {
                closeIdeasModal();
                showToast('Idea added to backlog!', 'success');
            } else {
                displayIdeasForValidation(window.pendingIdeas);
                showToast('Idea added to backlog!', 'success');
            }
        }
        
        function rejectIdea(index) {
            window.pendingIdeas.splice(index, 1);
            if (window.pendingIdeas.length === 0) {
                closeIdeasModal();
                showToast('Idea rejected', 'info');
            } else {
                displayIdeasForValidation(window.pendingIdeas);
            }
        }
        
        function closeIdeasModal() {
            document.getElementById('ideasModal').style.display = 'none';
            window.pendingIdeas = [];
        }

        function toggleHelpMenu() {
            const menu = document.getElementById('helpMenu');
            if (menu) {
                menu.classList.toggle('active');
            }
        }
        
        // Close help menu when clicking outside
        document.addEventListener('click', (e) => {
            const helpMenu = document.getElementById('helpMenu');
            const helpBtn = document.getElementById('helpButton');
            if (helpMenu && helpBtn && 
                !helpMenu.contains(e.target) && 
                !helpBtn.contains(e.target) &&
                helpMenu.classList.contains('active')) {
                helpMenu.classList.remove('active');
            }
        });
        
        // Make toggleHelpMenu available globally
        window.toggleHelpMenu = toggleHelpMenu;

        // Event listeners with automatic filter application
        const filterElements = ['searchInput', 'sourceFilter', 'sentimentFilter', 'ovhProductFilter', 'languageFilter', 'dateFrom', 'dateTo', 'sortBy'];
        
        filterElements.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                // Apply filters automatically on change
                el.addEventListener('input', () => {
                    currentOffset = 0;
                    saveFilters();
                    renderGallery();
                    updateActiveFiltersCount();
                });
                el.addEventListener('change', () => {
                    currentOffset = 0;
                    saveFilters();
                    renderGallery();
                    updateActiveFiltersCount();
                });
            }
        });
        
        // Apply filters button (still available for manual refresh)
        function applyFilters() {
            currentOffset = 0;
            renderGallery();
            updateActiveFiltersCount();
            addLog('üîç Filters applied', 'info');
            showToast('Filters applied successfully', 'success');
        }
        
        // Initialize event listeners after DOM is ready
        function initializeEventListeners() {
            // Enter key still works but filters now apply automatically on input/change
            // This is kept for immediate feedback when user presses Enter
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // Filters already apply automatically, but Enter can trigger immediate update
                        currentOffset = 0;
                        renderGallery();
                        updateActiveFiltersCount();
                    }
                });
            }
            
            console.log('‚úÖ Event listeners initialized (filters apply automatically)');
        }

        // Initialize default keywords if none exist
        function initializeDefaultKeywords() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                const defaultKeywords = [
                    'ovhcloud',
                    'ovh vps',
                    'ovh hosting',
                    'ovh dedicated',
                    'ovh cloud',
                    'ovh support',
                    'ovh billing'
                ];
                saveKeywords(defaultKeywords);
                addLog('üéØ Initialized default keywords covering main OVH products', 'info');
            }
        }
        
        // Load filters, posts from DB, and render
        loadFilters();
        initializeDefaultKeywords();
        initializeEventListeners();
        renderKeywords();
        loadPostsFromDB().then(() => {
            renderGallery();
            addLog('‚úÖ Application ready. Click "üÜï Scrape New Data" to collect posts from all sources.', 'info');
        });

        // --- Keywords manager: persist and run searches ---
        function loadKeywords() {
            const saved = localStorage.getItem('ovh_queries');
            return saved ? JSON.parse(saved) : [];
        }

        function saveKeywords(keywords) {
            localStorage.setItem('ovh_queries', JSON.stringify(keywords));
            // attempt to sync to server (fire-and-forget)
            syncKeywordsToServer(keywords).catch(err => {
                console.warn('Could not sync keywords to server:', err);
            });
        }

        function renderKeywords() {
            const list = document.getElementById('keywordsList');
            const keywords = loadKeywords();
            list.innerHTML = '';
            
            // Show count
            const countEl = document.querySelector('#keywordsList + small') || document.createElement('small');
            if (keywords.length > 0) {
                countEl.textContent = `${keywords.length} keyword${keywords.length > 1 ? 's' : ''} active`;
                countEl.style.color = '#00d4ff';
                countEl.style.marginLeft = '0';
                countEl.style.marginTop = '10px';
                countEl.style.width = '100%';
                countEl.style.textAlign = 'center';
                countEl.style.display = 'block';
                if (!countEl.parentNode) {
                    list.parentNode.insertBefore(countEl, list.nextSibling);
                }
            } else {
                countEl.textContent = '';
            }
            
            keywords.forEach((kw, idx) => {
                const chip = document.createElement('div');
                chip.style.padding = '6px 10px';
                chip.style.background = 'rgba(0,212,255,0.08)';
                chip.style.border = '1px solid rgba(0,212,255,0.12)';
                chip.style.borderRadius = '16px';
                chip.style.color = '#00d4ff';
                chip.style.fontSize = '0.9em';
                chip.style.display = 'inline-flex';
                chip.style.alignItems = 'center';
                chip.style.marginRight = '6px';
                chip.style.marginBottom = '6px';
                
                const textSpan = document.createElement('span');
                textSpan.textContent = kw;
                textSpan.style.cursor = 'pointer';
                textSpan.onclick = () => editKeyword(idx);
                chip.appendChild(textSpan);
                
                const rem = document.createElement('button');
                rem.textContent = '‚úï';
                rem.style.marginLeft = '8px';
                rem.style.background = 'transparent';
                rem.style.border = 'none';
                rem.style.color = '#ff9b9b';
                rem.style.cursor = 'pointer';
                rem.style.padding = '0';
                rem.style.width = '18px';
                rem.style.height = '18px';
                rem.onclick = (e) => { e.stopPropagation(); removeKeyword(idx); };
                chip.appendChild(rem);
                list.appendChild(chip);
            });
            if (keywords.length === 0) {
                list.innerHTML = '<small style="color:var(--text-muted);">No keywords defined ‚Äî add some to start searches.</small>';
            }
        }

        function editKeyword(index) {
            const keywords = loadKeywords();
            if (index < 0 || index >= keywords.length) return;
            const oldValue = keywords[index];
            const newValue = prompt('Edit keyword:', oldValue);
            if (newValue && newValue.trim() && newValue !== oldValue) {
                keywords[index] = newValue.trim();
                saveKeywords(keywords);
                renderKeywords();
                showToast('Keyword updated', 'success');
            }
        }


        function addKeyword() {
            const input = document.getElementById('keywordInput');
            const value = (input.value || '').trim();
            if (!value) return;
            let keywords = loadKeywords();
            if (keywords.length >= 10) { showToast('Max 10 keywords allowed', 'error'); return; }
            if (keywords.includes(value)) { showToast('Keyword already added', 'error'); input.value = ''; return; }
            keywords.push(value);
            saveKeywords(keywords);
            input.value = '';
            renderKeywords();
            showToast(`Added keyword: ${value}`, 'success');
        }

        function removeKeyword(index) {
            let keywords = loadKeywords();
            if (index < 0 || index >= keywords.length) return;
            const removed = keywords.splice(index,1)[0];
            saveKeywords(keywords);
            renderKeywords();
            showToast(`Removed: ${removed}`, 'info');
        }

        function clearKeywords() {
            if (!confirm('Clear all saved keywords?')) return;
            
            // Save current keywords before clearing (for revert)
            const currentKeywords = loadKeywords();
            if (currentKeywords && currentKeywords.length > 0) {
                localStorage.setItem('ovh_queries_backup', JSON.stringify(currentKeywords));
                document.getElementById('revertKeywordsBtn').style.display = 'inline-block';
            }
            
            localStorage.removeItem('ovh_queries');
            // also clear on server
            saveKeywords([]);
            renderKeywords();
            showToast('Keywords cleared', 'success');
        }

        function revertKeywords() {
            const backup = localStorage.getItem('ovh_queries_backup');
            if (!backup) {
                showToast('No backup found to restore', 'error');
                return;
            }
            
            try {
                const keywords = JSON.parse(backup);
                saveKeywords(keywords);
                renderKeywords();
                document.getElementById('revertKeywordsBtn').style.display = 'none';
                localStorage.removeItem('ovh_queries_backup');
                showToast('Keywords restored', 'success');
            } catch (e) {
                showToast('Error restoring keywords', 'error');
            }
        }

        // Sync functions with backend
        async function syncKeywordsToServer(keywords) {
            showSyncIndicator(true);
            addLog('üîÅ Syncing keywords to server...', 'info');
            try {
                const resp = await fetch(`${API_BASE}/settings/queries`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keywords })
                });
                if (!resp.ok) {
                    const txt = await resp.text();
                    showToast(`Server sync failed: ${txt}`, 'error');
                    addLog(`‚ùå Server sync failed: ${txt}`, 'error');
                    console.warn('Server sync failed', txt);
                } else {
                    showToast('Keywords synced to server', 'info');
                    addLog('‚úÖ Keywords synced to server', 'success');
                }
            } catch (e) {
                console.warn('syncKeywordsToServer error', e);
                showToast('Network error: could not sync keywords', 'error');
                addLog(`‚ùå Network error during keywords sync: ${e.message || e}`, 'error');
            } finally {
                showSyncIndicator(false);
            }
        }

        async function loadKeywordsFromServer() {
            showSyncIndicator(true);
            try {
                const resp = await fetch(`${API_BASE}/settings/queries`);
                if (!resp.ok) return renderKeywords();
                const data = await resp.json();
                if (data && Array.isArray(data.keywords) && data.keywords.length > 0) {
                    // overwrite local keywords with server list without re-syncing
                    localStorage.setItem('ovh_queries', JSON.stringify(data.keywords));
                    addLog('‚úÖ Loaded keywords from server', 'success');
                }
            } catch (e) {
                console.warn('Could not load keywords from server', e);
                addLog('‚ùå Could not load keywords from server', 'error');
            } finally {
                showSyncIndicator(false);
                renderKeywords();
            }
        }

        function showSyncIndicator(show) {
            const el = document.getElementById('keywordsSyncIndicator');
            if (!el) return;
            el.style.display = show ? 'inline-block' : 'none';
        }

        async function runKeywordSearches() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) {
                showToast('No keywords to search', 'error');
                return;
            }

            const limit = Math.max(1, Math.min(500, Number(document.getElementById('keywordLimit').value || 50)));
            clearLogs();
            showLogs();
            showCancelBtn(true);
            currentAbortController = new AbortController();

            addLog(`üîé Running searches for ${keywords.length} keywords (limit=${limit})`, 'info');

            const sources = ['x','github','stackoverflow','reddit','news','trustpilot'];

            try {
                for (const kw of keywords) {
                    addLog(`‚û°Ô∏è Keyword: "${kw}"`, 'info');
                    for (const s of sources) {
                        const url = `${API_BASE}/scrape/${s}?query=${encodeURIComponent(kw)}&limit=${limit}`;
                        addLog(`   ‚Ä¢ Calling ${s}...`, 'info');
                        try {
                            const resp = await fetch(url, { method: 'POST', signal: currentAbortController.signal });
                            if (resp.ok) {
                                const data = await resp.json();
                                addLog(`   ‚úì ${s}: added ${data.added}`, 'success');
                            } else {
                                const txt = await resp.text();
                                addLog(`   ‚úó ${s} error: ${txt}`, 'error');
                            }
                        } catch (e) {
                            if (e.name === 'AbortError') {
                                addLog('‚õî Operation aborted', 'error');
                                throw e;
                            } else {
                                addLog(`   ‚úó ${s} fetch failed: ${e.message}`, 'error');
                            }
                        }
                    }
                    // refresh posts after each keyword
                    await loadPostsFromDB();
                    renderGallery();
                }
                showToast('Keyword searches completed', 'success');
            } catch (e) {
                if (e.name === 'AbortError') {
                    showToast('Searches cancelled', 'error');
                } else {
                    showToast('Error during searches', 'error');
                }
            } finally {
                showCancelBtn(false);
                currentAbortController = null;
            }
        }

        // wire Enter key to add keyword
        document.getElementById('keywordInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); addKeyword(); }
        });

        // Render saved keywords on load
        renderKeywords();

        // Job polling / background job UI
        let jobPollInterval = null;

        function persistLastJob(jobId) {
            if (!jobId) return localStorage.removeItem('ovh_last_job');
            localStorage.setItem('ovh_last_job', jobId);
        }

        function loadLastJob() {
            return localStorage.getItem('ovh_last_job');
        }

        async function startBackgroundJob() {
            const keywords = loadKeywords();
            if (!keywords || keywords.length === 0) { showToast('No keywords to start job', 'error'); return; }
            const limit = Math.max(1, Math.min(500, Number(document.getElementById('keywordLimit').value || 50)));
            const concurrency = 2;
            const delay = 0.5;

            console.log('Starting background job for keywords...');
            try {
                const resp = await fetch(`${API_BASE}/scrape/keywords?limit=${limit}&concurrency=${concurrency}&delay=${delay}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keywords })
                });
                if (!resp.ok) {
                    const txt = await resp.text();
                    addLog(`‚ùå Failed to start background job: ${txt}`, 'error');
                    showToast('Failed to start job', 'error');
                    return;
                }
                const data = await resp.json();
                const jobId = data.job_id || data.jobId || data.id;
                if (!jobId) {
                    addLog('‚ùå No job id returned from server', 'error');
                    showToast('Server did not return job id', 'error');
                    return;
                }
                persistLastJob(jobId);
                addLog(`‚úÖ Background job started: ${jobId}`, 'success');
                document.getElementById('jobPanel').style.display = 'block';
                updateJobPanel({ id: jobId, status: 'pending', progress: { total: 0, completed: 0 } });
                // start polling
                if (jobPollInterval) clearInterval(jobPollInterval);
                jobPollInterval = setInterval(() => pollJobStatus(jobId), 2000);
                // immediate poll
                pollJobStatus(jobId);
            } catch (e) {
                addLog(`‚ùå Error starting background job: ${e.message}`, 'error');
                showToast('Network error starting job', 'error');
            }
        }

        async function pollJobStatus(jobId) {
            try {
                const resp = await fetch(`${API_BASE}/scrape/jobs/${encodeURIComponent(jobId)}`);
                if (!resp.ok) {
                    addLog(`‚ùå Could not fetch job ${jobId}: ${resp.statusText}`, 'error');
                    return;
                }
                const status = await resp.json();
                updateJobPanel(status);
                if (status.status === 'completed' || status.status === 'failed' || status.status === 'cancelled') {
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    persistLastJob(null);
                    showToast(`Job ${status.status}`, status.status === 'completed' ? 'success' : 'error');
                }
            } catch (e) {
                addLog(`‚ùå Error polling job: ${e.message}`, 'error');
            }
        }

        function updateJobPanel(status) {
            const statusText = document.getElementById('jobStatusText');
            const jobProgress = document.getElementById('jobProgress');
            const jobDetails = document.getElementById('jobDetails');
            if (!statusText || !jobProgress || !jobDetails) return;
            statusText.textContent = `Job: ${status.id || '‚Äì'} ‚Äî ${status.status || 'unknown'}`;
            const total = (status.progress && status.progress.total) || 0;
            const completed = (status.progress && status.progress.completed) || 0;
            jobProgress.innerHTML = `Progress: ${completed} / ${total}`;
            const results = Array.isArray(status.results) ? status.results.length : (status.results && status.results.length) || 0;
            const errors = Array.isArray(status.errors) ? status.errors.length : (status.errors && status.errors.length) || 0;
            jobDetails.innerHTML = `ID: ${status.id || '‚Äì'} <br> Results entries: ${results} ‚Ä¢ Errors: ${errors} <br> Updated: ${status.updated_at || ''}`;
            // also push some log lines for visibility
            if (status.results && status.results.length > 0) {
                const last = status.results[status.results.length-1];
                addLog(`üîî Task result: ${JSON.stringify(last)}`, 'info');
            }
            const jobErrorsEl = document.getElementById('jobErrors');
            const toggleBtn = document.getElementById('toggleErrorsBtn');
            if (status.errors && status.errors.length > 0) {
                const lastE = status.errors[status.errors.length-1];
                addLog(`‚ö†Ô∏è Task error: ${lastE}`, 'error');
                if (jobErrorsEl) {
                    jobErrorsEl.style.display = 'block';
                    jobErrorsEl.innerHTML = status.errors.map(e => `<div style="margin-bottom:6px;">${e}</div>`).join('');
                }
                if (toggleBtn) toggleBtn.style.display = 'inline-block';
            } else {
                if (jobErrorsEl) {
                    jobErrorsEl.style.display = 'none';
                    jobErrorsEl.innerHTML = '';
                }
                if (toggleBtn) toggleBtn.style.display = 'none';
            }
        }

        function toggleJobErrors() {
            const el = document.getElementById('jobErrors');
            if (!el) return;
            el.style.display = (el.style.display === 'block') ? 'none' : 'block';
        }

        async function cancelBackgroundJob() {
            const jobId = loadLastJob();
            if (!jobId) {
                showToast('No active job to cancel', 'error');
                return;
            }
            try {
                const resp = await fetch(`${API_BASE}/scrape/jobs/${encodeURIComponent(jobId)}/cancel`, { method: 'POST' });
                if (resp.ok) {
                    addLog(`üõë Cancel requested for job ${jobId}`, 'info');
                    persistLastJob(null);
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    document.getElementById('jobPanel').style.display = 'none';
                    showToast('Job cancellation requested', 'info');
                } else {
                    const txt = await resp.text();
                    addLog(`‚ùå Cancel failed: ${txt}`, 'error');
                    showToast('Cancel failed', 'error');
                }
            } catch (e) {
                addLog(`‚ùå Error cancelling job: ${e.message}`, 'error');
                showToast('Network error cancelling job', 'error');
            }
        }

        // On load, if there's a recent job, resume polling
        (function resumeLastJob() {
            const last = loadLastJob();
            if (last) {
                document.getElementById('jobPanel').style.display = 'block';
                jobPollInterval = setInterval(() => pollJobStatus(last), 2000);
                pollJobStatus(last);
            }
        })();

        // --- Job Errors Modal ---
        // Create modal HTML dynamically and attach to body
        (function createJobErrorsModal(){
            const overlay = document.createElement('div');
            overlay.id = 'jobErrorsModal';
            overlay.className = 'job-errors-modal-overlay';
            overlay.innerHTML = `
                <div class="job-errors-modal" role="dialog" aria-modal="true">
                    <div class="job-errors-header">
                        <h3 class="job-errors-title">Erreurs du job</h3>
                        <div class="job-errors-actions">
                            <button id="copyErrorsBtn" class="btn btn-copy">Copier</button>
                            <button id="downloadErrorsBtn" class="btn btn-ghost">T√©l√©charger</button>
                            <button id="closeErrorsBtn" class="btn btn-danger">Fermer</button>
                        </div>
                    </div>
                    <div id="jobErrorsContent" class="job-errors-content"></div>
                </div>
            `;
            document.body.appendChild(overlay);

            // close handlers
            document.getElementById('closeErrorsBtn').onclick = () => { overlay.style.display='none'; };
            overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display='none'; });

            document.getElementById('copyErrorsBtn').onclick = async () => {
                const txt = document.getElementById('jobErrorsContent').innerText;
                try { await navigator.clipboard.writeText(txt); showToast('Erreurs copi√©es', 'info'); } catch(e){ showToast('Impossible de copier', 'error'); }
            };

            document.getElementById('downloadErrorsBtn').onclick = () => {
                const txt = document.getElementById('jobErrorsContent').innerText;
                const blob = new Blob([txt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `job-errors-${new Date().toISOString()}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            };
        })();

        function openJobErrorsModal() {
            const overlay = document.getElementById('jobErrorsModal');
            const content = document.getElementById('jobErrorsContent');
            const jobErrorsEl = document.getElementById('jobErrors');
            if (!overlay || !content) return;
            content.innerText = jobErrorsEl ? jobErrorsEl.innerText : 'Aucune erreur.';
            overlay.style.display = 'flex';
        }

        // Version Switch Modal functions
        function openVersionSwitchModal() {
            console.log('Opening version switch modal...');
            const modal = document.getElementById('versionModal');
            if (modal) {
                console.log('Modal found, displaying...');
                modal.style.display = 'flex';
            } else {
                console.error('Version modal not found!');
            }
        }

        function closeVersionModal() {
            const modal = document.getElementById('versionModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function switchToVersion(version) {
            try {
                console.log('Switching to version:', version);
                const response = await fetch(`${API_BASE}/admin/set-ui-version`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ version: version })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    console.error('Failed to switch version:', error);
                    showToast(`Failed to switch version: ${error.detail}`, 'error');
                    return;
                }
                
                const result = await response.json();
                console.log('Version switch response:', result);
                showToast(`Switching to ${version === 'v1' ? 'Scraping' : 'Dashboard'}...`, 'info');
                
                // Force a hard redirect to the appropriate page
                setTimeout(() => {
                    if (version === 'v1') {
                        window.location.href = '/scraping';
                    } else {
                        window.location.href = '/dashboard';
                    }
                }, 500);
            } catch (e) {
                console.error('Switch version error:', e);
                showToast(`Error switching version: ${e.message}`, 'error');
            }
        }

        // Make functions available globally
        window.openVersionModal = openVersionSwitchModal;
        window.closeVersionModal = closeVersionModal;
        window.switchToVersion = switchToVersion;

        // Setup version toggle button
        document.addEventListener('DOMContentLoaded', () => {
            const versionToggleBtn = document.getElementById('versionToggleBtn');
            if (versionToggleBtn) {
                versionToggleBtn.addEventListener('click', openVersionSwitchModal);
            }
        });
        // LLM Configuration Functions
        // LLM Configuration functions removed - now in Settings page
        async function loadLLMConfig() {
            try {
                const response = await fetch('/api/llm-config');
                if (!response.ok) throw new Error('Failed to load config');
                const config = await response.json();
                
                // Update provider select
                const providerSelect = document.getElementById('llmProvider');
                if (providerSelect) {
                    providerSelect.value = config.llm_provider || 'openai';
                }
                
                // Show status (don't show actual keys for security)
                const statusDiv = document.getElementById('llmConfigStatus');
                const statusText = document.getElementById('llmConfigStatusText');
                if (statusDiv && statusText) {
                    if (config.status === 'configured') {
                        const providers = [];
                        if (config.openai_api_key_set) providers.push('OpenAI');
                        if (config.anthropic_api_key_set) providers.push('Anthropic');
                        statusText.innerHTML = `‚úÖ LLM configured: ${providers.join(', ')} | Provider: ${config.llm_provider}`;
                        statusDiv.style.background = 'rgba(52, 211, 153, 0.1)';
                        statusDiv.style.borderColor = 'rgba(52, 211, 153, 0.3)';
                        statusDiv.style.color = '#34d399';
                    } else {
                        statusText.textContent = '‚ö†Ô∏è No LLM API keys configured. AI features will use fallback mode.';
                        statusDiv.style.background = 'rgba(245, 158, 11, 0.1)';
                        statusDiv.style.borderColor = 'rgba(245, 158, 11, 0.3)';
                        statusDiv.style.color = '#f59e0b';
                    }
                    statusDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading LLM config:', error);
                const statusDiv = document.getElementById('llmConfigStatus');
                const statusText = document.getElementById('llmConfigStatusText');
                if (statusDiv && statusText) {
                    statusText.textContent = '‚ùå Error loading configuration';
                    statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                    statusDiv.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                    statusDiv.style.color = '#ef4444';
                    statusDiv.style.display = 'block';
                }
            }
        }

        async function saveLLMConfig() {
            const openaiKey = document.getElementById('openaiApiKey')?.value.trim() || null;
            const anthropicKey = document.getElementById('anthropicApiKey')?.value.trim() || null;
            const provider = document.getElementById('llmProvider')?.value || 'openai';
            
            // If keys are empty strings, set to null to clear them
            const payload = {
                openai_api_key: openaiKey || null,
                anthropic_api_key: anthropicKey || null,
                llm_provider: provider
            };
            
            try {
                const response = await fetch('/api/llm-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to save config');
                }
                
                const result = await response.json();
                
                // Show success message
                const statusDiv = document.getElementById('llmConfigStatus');
                const statusText = document.getElementById('llmConfigStatusText');
                if (statusDiv && statusText) {
                    statusText.innerHTML = `‚úÖ LLM configuration saved successfully! Provider: ${result.llm_provider}`;
                    statusDiv.style.background = 'rgba(52, 211, 153, 0.1)';
                    statusDiv.style.borderColor = 'rgba(52, 211, 153, 0.3)';
                    statusDiv.style.color = '#34d399';
                    statusDiv.style.display = 'block';
                }
                
                // Clear password fields (for security, don't keep them visible)
                if (document.getElementById('openaiApiKey')) {
                    document.getElementById('openaiApiKey').value = '';
                }
                if (document.getElementById('anthropicApiKey')) {
                    document.getElementById('anthropicApiKey').value = '';
                }
                
                // Reload config to show updated status
                setTimeout(() => loadLLMConfig(), 1000);
                
            } catch (error) {
                console.error('Error saving LLM config:', error);
                const statusDiv = document.getElementById('llmConfigStatus');
                const statusText = document.getElementById('llmConfigStatusText');
                if (statusDiv && statusText) {
                    statusText.textContent = `‚ùå Error: ${error.message}`;
                    statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                    statusDiv.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                    statusDiv.style.color = '#ef4444';
                    statusDiv.style.display = 'block';
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const versionToggleBtn = document.getElementById('versionToggleBtn');
            if (versionToggleBtn) {
                versionToggleBtn.addEventListener('click', openVersionSwitchModal);
            }
            // Load posts and stats on page load
            loadPostsFromDB().then(() => {
                console.log('Posts and stats loaded successfully');
            }).catch(error => {
                console.error('Error loading posts:', error);
            });
            });
        </script>
        <script src="/js/logo-updater.js"></script>
    </body>
</html>
